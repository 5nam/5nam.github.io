---
layout: single
title:  "[SPRING MVC] MVC 기본 기능"
categories: spring_mvc
toc: true
author_profile: false
sidebar:
    nav: "docs"
---



## 프로젝트 생성

- Dependencies : Spring Web, Thymeleaf, Lombok
- Jar 사용하면 항상 내장 서버(톰캣 등)를 사용하고, webapp 경로도 사용하지 않음
- War 를 사용하는 경우는, WAS 서버(서블릿 컨테이너)를 별도로 설치하고 빌드된 파일을 넣는 식으로 배포할 때 War 사용

- Welcome 페이지는 /resources/static/index.html 로 만들어 주면 됨



## 로깅 알아보기

**로깅 라이브러리**

- 수 많은 로그 라이브러리들을 통합해서 인터페이스로 제공하는 것이 SLF4J 인터페이스
  - 그 구현체로 Logback 같은 로그 라이브러리 선택하면 됨



LogTestController

```java
package hello.springmvc.basic;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


//@Slf4j
@RestController
public class LogTestController {

    private final Logger log = LoggerFactory.getLogger(getClass());

    @RequestMapping("/log-test")
    public String logTest() {

        String name = "Spring";

        log.trace("trace log = {}", name);
        log.debug("debug log = {}", name);
        log.info("info log = {}", name);
        log.warn("warn log = {}", name);
        log.error("error log = {}", name);

        // 로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하지 않아도 됨
        log.debug("String concat log = " + name);
        return "ok";
    }
}

```

- :star: 매핑 정보

  `@RestController`

  - `@Controller` 는 반환 값이 String 이면 뷰 이름으로 인식. 그래서 **뷰를 찾고 뷰가 렌더링 됨**
  - `@RestController` 는 반환 값으로 뷰를 찾는 것이 아니라, **HTTP 메시지 바디에 바로 입력**

- 테스트

  ![image-20240922203905144]({{site.url}}/images/2024-09-22-springmvc(6)/image-20240922203905144.png)

  로그가 출력되는 포맷

  - 시간, 로그 레벨, 프로세스 ID, 쓰레드 명, 클래스명, 로그 메시지

  로그 레벨 설정을 변경해서 출력 결과 보자

  - LEVEL : TRACE > DEBUG > INFO > WARN > ERROR
  - 개발 서버는 debug 출력
  - 운영 서버는 info 출력 : 트래픽도 많고 운영에 중요한 정보들만 남겨야 함, 실제 서비스에서는 info 레벨로 많이 남김

  `@Slf4j` 로 변경



**로그 레벨 설정(application.properties)**

```properties
logging.level.root=info
```

- 내가 생성한 클래스 이외에도 라이브러리까지 설정함(설정의 범위)
- debug 로. 바꾸면 수만 가지의 로그들 남음

```properties
logging.level.hello.springmvc=debug
```

- hello.spring.mvc 패키지와 그 하위를 대상으로 한 로그 레벨 설정



**:star: 올바른 로그 사용법**

- `log.debug("data="+data)`

  - 이렇게 사용하면 안됨. 로그 출력을 info 로 설정해도 해당 코드에 있는 "data="+data 가 실제 실행되어 버림

  - 결과적으로 문자 더하기 연산 발생

  - 자바 특성 상 메서드를 호출하기 전에 괄호 안의 '+' 연산 실행해 버림

    :arrow_right: 연산이 일어난다는 건 메모리/CPU 모두 사용하는 것이므로 낭비

- `log.debug("data={}", data)`

  - 로그 출력 레벨을 info 로 설정하면 아무 일도 발생하지 않음
  - 파라미터를 넘기면 메서드 안에서만 연산되고, 메서드가 실행 안되면 연산하지 않음



**로그 사용시 장점**

- 쓰레드 정보, 클래스 이름 같은 부가 정보 함께 볼 수 있고, 출력 모양 조정 가능

- 로그 레벨에 따라 개발 서버에서는 모든 로그 출력, 운영 서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절 가능

  - 애플리케이션 코드를 건들지 않고, properties 설정만으로 조정 가능하다는 점이 강점

- 시스템 아웃 콘솔에만 출력하는 것이 아니라, 설정을 통해 파일이나 네트워크 등 로그를 별도의 위치에 남길 수 있음

  - 파일로 남길 때 일별, 특정 용량에 따라 로그 분할 하는 것도 가능

- 성능도 일반 System.out 보다 좋음

  - 내부 버퍼링, 멀티 쓰레 등등

    :arrow_right: 로그가 한번에 몰려도 내부에서 버퍼링하고, 멀티 스레드 관련 이슈까지 다 해결하면서 성능을 극한으로 최적화



## 요청 매핑

- 요청이 왔을 때 어떤 Controller 가 호출이 되어야 하는지 맵핑하는 것
  - 단순하게 URL 로 맵핑하는 방법 뿐만 아니라 여로 요소들로 조합하여 맵핑



**MappingController**

```java
package hello.springmvc.basic.requestmapping;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MappingController {

    private Logger log = LoggerFactory.getLogger(getClass());

    /**
     * 기본 요청
     * 둘다 허용 /hello-basic, /hello-basic
     * HTTP 메서드 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE
     */
    @RequestMapping("/hello-basic") // URL 오면 이 메서드 호출되도록
    public String helloBasic() {
        log.info("helloBasic");
        return "ok";
    }
}
```



**매핑 정보(한번 더)**

- `@RequestMapping("/hello-basic")`
  - 대부분의 속성을 배열[] 로 제공하므로 다중 설정이 가능함. `{"/hello-basic", "/hello-go"}`



**스프링 부트 3.0 이후**

`/hello-basic`, `/hello-basic/` 는 서로 다른 URL 로 인식된다



**HTTP 메서드**

`@RequestMapping` 에 method 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출

GET, HEAD, POST, PUT, PATCH, DELETE 모두 허용하는 것



#### HTTP 메서드 매핑

```java
    /**
     * method 특정 HTTP 메서드 요청만 허용
     * GET, HEAD, POST, PUT, PATCH, DELETE
     */
    @RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET)
    public String mappingGetV1() {
        log.info("mappingGetV1");
        return "ok";
    }
```

- 여기서 POST 요청을 하면 스프링 MVC 는 HTTP 405 상태코드(Method Not Allowed) 를 반환



#### HTTP 메서드 매핑 축약

```java
    /**
     * 편리한 축약 애노테이션
     * @GetMapping
     * @PostMapping
     * @PutMapping
     * @DeleteMapping
     * @PatchMapping
     */
    @GetMapping(value = "/mapping-get-v2")
    public String mappingGetV2() {
        log.info("mapping-get-v2");
        return "ok";
    }
```

- 축약 버전을 사용하는 것이 더 직관적, 애노테이션 내부에 `@RequestMapping` 의 method 로 지정해놓은 것을 확인

  ![image-20240922214349631]({{site.url}}/images/2024-09-22-springmvc(6)/image-20240922214349631.png)

#### :star: PathVariable(경로 변수) 사용

```java
    /**
     * PathVariable 사용
     * 변수명이 같으면 생략 가능
     * @PathVariable("userId") String userId -> @PathVariable String userId
     */
    @GetMapping("/mapping/{userId}")
    public String mappingPath(@PathVariable("userId") String data) {
        log.info("mappingPath userId={}", data);
        return "ok";
    }
```

- `@RequestMapping` 은 URL 경로를 템플릿화(`/mapping/{userId}`) 할 수 있음
- `@PathVariable` 의 이름과 파라미터 이름이 같으면 생략할 수 있음



#### PathVariable 사용 - 다중

```java
    /**
     * PathVariable 사용 다중
     */
    @GetMapping("/mapping/users/{userId}/orders/{orderId}")
    public String mappingPath(@PathVariable String userId, @PathVariable Long
            orderId) {
        log.info("mappingPath userId={}, orderId={}", userId, orderId);
        return "ok";
    }
```



#### 특정 파라미터 조건 매핑

```java
    /**
     * 파라미터로 추가 매핑
     * params="mode",
     * params="!mode"
     * params="mode=debug"
     * params="mode!=debug" (! = )
     * params = {"mode=debug","data=good"}
     */
    @GetMapping(value = "/mapping-param", params = "mode=debug")
    public String mappingParam() {
        log.info("mappingParam");
        return "ok";
    }
```

- `mode = debug`

  - 요청 파라미터에 mode = debug 라는게 있어야 호출이 되는 것

    예) /mapping-param?mode=debug

- 특정 파라미터가 있거나 없는 조건을 추가할 수는 있으나 잘 사용하지 않음



#### 특정 헤더 조건 매핑

```java
    /**
     * 특정 헤더로 추가 매핑
     * headers="mode",
     * headers="!mode"
     * headers="mode=debug"
     * headers="mode!=debug" (! = )
     */
    @GetMapping(value = "/mapping-header", headers = "mode=debug")
    public String mappingHeader() {
        log.info("mappingHeader");
        return "ok";
    }
```

- 파라미터 매핑과 비슷하지만, HTTP 헤더를 사용



#### 미디어 타입 조건 매핑 - HTTP 요청 Content-Type, consume

```java
    /**
     * Content-Type 헤더 기반 추가 매핑 Media Type
     * consumes="application/json"
     * consumes="!application/json"
     * consumes="application/*"
     * consumes="*\/*"
     * MediaType.APPLICATION_JSON_VALUE
     */
    @PostMapping(value = "/mapping-consume", consumes = "application/json")
    public String mappingConsumes() {
        log.info("mappingConsumes");
        return "ok";
    }
```

- 위의 것처럼 `headers="Content-Type=~"` 이런 식으로 써도 되지만, 위의 코드가 부가적인 기능을 더 제공하므로 좋음
  - headers 쓰지 말고, consume 을 써야함(spring mvc 내부 처리 방식에 따라)
- HTTP 요청의 Content-Type 헤더를 기반으로 미디어 타입으로 매핑
  - 만약 맞지 않으면 HTTP 415 상태코드(Unsupported Media Type) 을 반환

- 예) consumes

  ```
  consumes = "text/plain"
  consumes = {"text/plain", "application/*"}
  consumes = MediaType.TEXT_PLAIN_VALUE
  ```

  

#### 미디어 타입 조건 매핑 - HTTP 요청 Accept, produce

- Controller 가 생산해내는 Content-Type 일 헤더의 Content-Type 과 알맞아야 하는 것

```java
    /**
     * Accept 헤더 기반 Media Type
     * produces = "text/html"
     * produces = "!text/html"
     * produces = "text/*"
     * produces = "*\/*"
     */
    @PostMapping(value = "/mapping-produce", produces = "text/html")
    public String mappingProduces() {
        log.info("mappingProduces");
        return "ok";
    }
```

- `produces = "text/html"` : Accept 헤더와 맞춰보는 것. 이게 맞아야 호출됨
- 만약에 맞지 않으면 HTTP 406 상태코드(Not Acceptable)을 반환

예시)

```
produces = "text/plain"
produces = {"text/plain", "application/*"}
produces = MediaType.TEXT_PLAIN_VALUE
produces = "text/plain;charset=UTF-8"
```



### API 예시

회원 관리 API

- 회원 목록 조회 : GET `/users`
- 회원 등록 : POST `/users`
- 회원 조회 : GET `/users/{userId}`
- 회원 수정 : PATCH `/users/{userId}`
- 회원 삭제 : DELETE `/users/{userId}`



#### MappingClassController

```java
package hello.springmvc.basic.requestmapping;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/mapping/users")
public class MappingClassController {

    /**
     * GET /mapping/users
     */
    @GetMapping
    public String users() {
        return "get users";
    }

    /**
     * POST /mapping/users
     */
    @PostMapping
    public String addUser() {
        return "post user";
    }

    /**
     * GET /mapping/users/{userId}
     */
    @GetMapping("/{userId}")
    public String findUser(@PathVariable String userId) {
        return "get userId=" + userId;
    }

    /**
     * PATCH /mapping/users/{userId}
     */
    @PatchMapping("/{userId}")
    public String updateUser(@PathVariable String userId) {
        return "update userId=" + userId;
    }

    /**
     * DELETE /mapping/users/{userId}
     */
    @DeleteMapping("/{userId}")
    public String deleteUser(@PathVariable String userId) {
        return "delete userId=" + userId;
    }
    
}

```

- `@RequestMapping("/mapping/users")`
  - 클래스 레벨에 매핑 정보를 두면 메서드 레벨에서 해당 정보 조합해서 사용

## HTTP 요청

### 기본, 헤더 조회

- 스프링 MVC 가 HTTP 헤더 정보를 조회하는 방법

#### RequestHeaderController

```java
package hello.springmvc.basic.request;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpMethod;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Locale;

@Slf4j
@RestController
public class RequestHeaderController {

    @RequestMapping("/headers")
    public String headers(HttpServletRequest request,
                          HttpServletResponse response,
                          HttpMethod httpMethod,
                          Locale locale,
                          @RequestHeader MultiValueMap<String, String> headerMap,
                          @RequestHeader("host") String host,
                          @CookieValue(value = "myCookie", required = false) String cookie) {

        log.info("request={}", request);
        log.info("response={}", response);
        log.info("httpMethod={}", httpMethod);
        log.info("locale={}", locale);
        log.info("headerMap={}", headerMap);
        log.info("header host={}", host);
        log.info("myCookie={}", cookie);
        return "ok";

    }
}

```

- HttpMethod : HTTP 메서드를 조회
- Locale : Locale 정보를 조회, 스프링은 여러가지 Locale 정보가 왔을 때 처리하는 LocaleResolver 가 있음

- `@RequstHeader MultiValueMap<String, String> headerMap`

  - 모든 HTTP 헤더를 MultiValueMap 형식으로 조회

- `@RequestHeader("host") String host`

  - 특정 HTTP 헤더를 조회
  - 속성
    - 필수 값 여부 : `required`
    - 기본 값 속성 : `defaultValue`

- `@CookieValue(value = "myCookie", required = false) String cooke`

  - 특정 쿠키를 조회
  - 속성
    - 필수 값 여부 : `required`
    - 기본 값 : `defaultValue`

- `MultiValueMap`

  - MAP 과 유사한데, 하나의 키에 여러 값을 받을 수 있다.
  - HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용
    - keyA=value1&keyA=value2

  ```java
  MultiValueMap<String, String> map = new LinkedMultiValueMap();
  map.add("keyA", "value1");
  map.add("keyA", "value2");
  
  //[value1,value2]
  List<String> values = map.get("keyA");
  ```

  

**:star: 추천) @Controller 의 [사용 가능한 파라미터 목록](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html), [사용 가능한 응답 값 목록](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/return-types.html)의 공식 메뉴얼 읽어보기!**



### HTTP 요청 파라미터 

**[클라이언트 :arrow_right: 서버] 요청 데이터 전달할 때 주로 3가지 방법 사용**

1. GET - 쿼리 파라미터(`@RequestParam 사용`)
   - `/url?username=hello&age=20`
   - 메시지 바디 없이, URL 의 쿼리 파라미터에 데이터를 포함해서 전달
   - 예) 검색, 필터, 페이징 등에 많이 사용
2. POST - HTML Form(`@RequestParam 사용`)
   - content-type : application/x-www-form-urlencoded
   - 메시지 바디에 쿼리 파라미터 형식으로 전달 `useranme=hello&age=20`
   - 예) 회원 가입, 상품 주문, HTML Form 사용
3. HTTP message body 에 데이터를 직접 담아서 요청
   - HTTP API 에서 주로 사용, JSON, XML, TEXT
   - 데이터 형식은 주로 JSON 사용
   - POST, PUS, PATCH



#### [요청 파라미터] 쿼리 파라미터, HTML Form

**[클라이언트 :arrow_right: 서버] 요청 데이터 전달할 때 주로 3가지 방법 사용**

1. :white_check_mark: **GET - 쿼리 파라미터(`@RequestParam 사용`)**

   - `/url?username=hello&age=20`
   - 메시지 바디 없이, URL 의 쿼리 파라미터에 데이터를 포함해서 전달
   - 예) 검색, 필터, 페이징 등에 많이 사용

2. :white_check_mark: **POST - HTML Form(`@RequestParam 사용`)**

   - content-type : application/x-www-form-urlencoded
   - 메시지 바디에 쿼리 파라미터 형식으로 전달 `useranme=hello&age=20`
   - 예) 회원 가입, 상품 주문, HTML Form 사용

3. HTTP message body 에 데이터를 직접 담아서 요청

   - HTTP API 에서 주로 사용, JSON, XML, TEXT
   - 데이터 형식은 주로 JSON 사용
   - POST, PUS, PATCH

   

- **GET 쿼리 파라미터 전송 방식, POST HTML Form 전송 방식이든 둘다 형식이 같으므로 구분 없이 조회 가능**
  - 이를 간단히 **요청 파라미터(request parameter) 조회**라고 함



**RequestParamController**

```java
package hello.springmvc.basic.request;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import java.io.IOException;

@Slf4j
@Controller
public class RequestParamController {
    /**
     * 반환 타입 없으면서 응답을 직접 넣으면, view 조회 X
     */
    @RequestMapping("/request-param-v1")
    public void requestParamV1(HttpServletRequest request,
                               HttpServletResponse response) throws IOException {

        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));
        log.info("username = {}, age = {}", username, age);

        response.getWriter().write("ok");
    }
}

```



Jar 사용 시 webapp 경로 사용 가능. 정적 리소스도 클래스 경로에 함께 포함해야 함



#### [요청 파라미터] @RequestParam



**requestParamV2**

```java
package hello.springmvc.basic.request;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import java.io.IOException;

@Slf4j
@Controller
public class RequestParamController {
    /**
     * 반환 타입 없으면서 응답을 직접 넣으면, view 조회 X
     */
    @RequestMapping("/request-param-v1")
    public void requestParamV1(HttpServletRequest request,
                               HttpServletResponse response) throws IOException {

        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));
        log.info("username = {}, age = {}", username, age);

        response.getWriter().write("ok");
    }

    /**
     * @RequestParam 사용
     * - 파라미터 이름으로 바인딩
     * @ResponseBody 추가
     * - View 조회를 무시하고, HTTP message body 에 직접 해당 내용 입력
     */

    @ResponseBody
    @RequestMapping("/request-param-v2")
    public String requestParamV2(
            @RequestParam("username") String memberName,
            @RequestParam("age") int memberAge) {

        log.info("username = {}, age = {}", memberName, memberAge);
        return "ok";
    }
}

```

- @RequestParam : 파라미터 이름으로 바인딩
- @ResponseBody : View 조회를 무시, HTTP message body에 직접 해당 내용 입력



**requestParamV3**

```java
    /**
     * @RequestParam 사용
     * HTTP 파라미터 이름이 변수 이름과 같으면 @RequestParam(name="xx") 생략 가능
     */
    @ResponseBody
    @RequestMapping("/request-param-v3")
    public String requestParamV3(
            @RequestParam String username,
            @RequestParam int age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```



**requestParamV4**

```java
    /**
     * @RequestParam 사용
     * String, int 등의 단순 타입이면 @RequestParam 도 생략 가능
     */
    @ResponseBody
    @RequestMapping("/request-param-v4")
    public String requestParamV4(String username, int age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

- `@RequestParam` 애노테이션을 생략하면 스프링 MVC 는 내부에서 `required=false` 를 적용
- 이렇게 아예 생략하는 것에 대해서는 과하다는 의견도 있음.



**주의! 스프링 부트 3.2 파라미터 이름 인식 문제**

해결 방안1(권장)

- 애노테이션의 이름을 생략하지 않고 다음과 같이 항상 이름을 적어준다. **:warning: 이 방법 권장!**

  `@RequestParam("usrname") String username`

  `@PathVariable("userId") String userId`



**파라미터 필수 여부 - requestParamRequired**

```java
    /**
     * @RequestParam.required
     * /request-param-required -> username 이 없으므로 예외
     *
     * 주의!
     * /request-param-required?username= -> 빈문자로 통과
     *
     * 주의!
     * /request-param-required
     * int age -> null 을 int 에 입력하는 것은 불가능, 따라서 Integer 변경해야 함(또는 다음에 나오는 defaultValue 사용)
     */
    @ResponseBody
    @RequestMapping("/request-param-required")
    public String requestParamRequired(
            @RequestParam(required = true) String username,
            @RequestParam(required = false) Integer age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

- `@RequestParam.required`
  - 파라미터 필수 여부(기본 값 파라미터 필수[true])
- @RequestParam.required
       * `/request-param-required` :arrow_right: username 이 없으므로 예외

- 주의! 파라미터 이름만 사용(null 과 빈문자열[""]은 분명하게 다름)
       * `/request-param-required?username=` :arrow_right: 빈문자로 통과

- 주의! 기본형(primitive)에 null 입력 불가
     * `/request-param-required`
     * int age 
     
       :arrow_right: null 을 int 에 입력하는 것은 불가능, 따라서 Integer 변경해야 함(또는 다음에 나오는 defaultValue 사용)



**기본 값 적용 - requestPramDefault**

```java
    /**
     * @RequestParam
     * - defaultValue 사용
     *
     * 참고: defaultValue 는 빈 문자의 경우에도 적용
     * /request-param-default?username=
     */
    @ResponseBody
    @RequestMapping("/request-param-default")
    public String requestParamDefault(
            @RequestParam(required = true, defaultValue = "guest") String username,
            @RequestParam(required = false, defaultValue = "-1") int age) {
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

- 파라미터에 값이 없는 경우 `defaultValue` 를 사용하면 기본 값 적용 가능
  - 기본 값이 있으면 required 는 의미가 없음
- `defaultValue` 는 **빈 문자의 경우에도 설정한 기본 값 적용**



파라미터를 Map 으로 조회하기 - requestParamMap

```java
    /**
     * @RequestParam Map, MultiValueMap
     * Map(key=value)
     * MultiValueMap(key=[value1, value2, ...]) ex) (key=userIds, value=[id1, id2])
     */
    @ResponseBody
    @RequestMapping("/request-param-map")
    public String requestParamMap(@RequestParam Map<String, Object> paramMap) {
        log.info("username={}, age={}", paramMap.get("username"),
                paramMap.get("age"));
        return "ok";
    }
```

- 파라미터 Map, MultiValueMap 으로 조회 가능
  - `@RequestParam Map, Map(key-value)`
  - `@RequestParam MultValueMap, MultiValueMap(ket=[value1, value2, ...])`
    - 예) (key=userIds, value = [id1, id2])

- 파라미터 값이 1개가 확실하다면 Map 을 사용해도 되지만, 그렇지 않다면 MultiValueMap 사용



#### [요청 파라미터] @ModelAttribute

- 요청 파라미터를 받아서 필요한 객체를 만들고, 그 객체에 값을 넣어주어야 함
  - 파라미터를 하나하나 조회해서 객체로 바꾸어주는 편리한 방법



**HelloData** : 요청 파라미터를 바인딩 받을 객체

```java
package hello.springmvc.basic;

import lombok.Data;

@Data
public class HelloData {
    private String username;
    private int age;
}
```

- 롬복 `@Data`

  - `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`

  ![image-20240922231851329]({{site.url}}/images/2024-09-22-springmvc(6)/image-20240922231851329.png)



**@ModelAttribute 적용 - modelAttributeV1**(RequestParamController 에 추가)

```java
    /**
     * @ModelAttribute 사용
     * 참고 : model.addAttribute(helloData) 코드도 함께 자동 적용됨
     */
    @ResponseBody
    @RequestMapping("/model-attribute-v1")
    public String modelAttributeV1(@ModelAttribute HelloData helloData) {
        log.info("username = {}, age = {}", helloData.getUsername(), helloData.getAge());
        return "ok";
    }
```

- `@ModelAttribute` 동작 과정

  1. HelloData 객체 생성

  2. 요청 파라미터의 이름으로 HelloData **객체의 프로퍼티(setXXX, getXXX)**를 찾는다. 그리고 해당 프로퍼티의 setter 호출해서 파라미터의 값을 입력(바인딩)

     예) 파라미터 이름이 username 이면 setUsername() 메서드를 찾아서 호출하면서 값을 입력



**프로퍼티**

- 객체에 getUsername(), setUsername() 메서드가 있으면, 이 객체는 username 이라는 프로퍼티를 가지고 있음



**바인딩 오류**

- age=abc 처럼 숫자가 들어가야 할 곳에 문자를 넣으면 `BindException` 발생
- 바인딩 오류를 처리하는 방법은 검증 부분에서 다룰 것



**@ModelAttribute 생략 - modelAttributeV2**

```java
    /**
     * @ModelAttribute 생략 가능
     * String, int 같은 단순 타입 = @RequestParam
     * argument resolver 로 지정해둔 타입 외 = @ModelAttribute
     */
    @ResponseBody
    @RequestMapping("/model-attribute-v2")
    public String modelAttributeV2(HelloData helloData) {
        log.info("username = {}, age = {}", helloData.getUsername(), helloData.getAge());
        return "ok";
    }
```

- 스프링은 생략시 다음과 같은 규칙 적용
  - String, int, Integer 같은 단순 타입 = @RequestParam
  - 나머지 = @ModelAttribute (argument resolver 로 지정해둔 타입 외, 이건 ModelAttribute 가 적용되지 않음)
    - argument resolver 예) HttpServletRequest 등 예약된 것들

#### [요청 파라미터] 단순 텍스트

**[클라이언트 :arrow_right: 서버] 요청 데이터 전달할 때 주로 3가지 방법 사용**

1. GET - 쿼리 파라미터(`@RequestParam 사용`)
   - `/url?username=hello&age=20`
   - 메시지 바디 없이, URL 의 쿼리 파라미터에 데이터를 포함해서 전달
   - 예) 검색, 필터, 페이징 등에 많이 사용
2. POST - HTML Form(`@RequestParam 사용`)
   - content-type : application/x-www-form-urlencoded
   - 메시지 바디에 쿼리 파라미터 형식으로 전달 `useranme=hello&age=20`
   - 예) 회원 가입, 상품 주문, HTML Form 사용
3. :white_check_mark: **HTTP message body 에 데이터를 직접 담아서 요청**(이 부분!)
   - HTTP API 에서 주로 사용, JSON, XML, TEXT
   - 데이터 형식은 주로 JSON 사용
   - POST, PUS, PATCH



- 요청 파라미터(1, 2번 방식)와 다르게, HTTP 메시지 바디를 통해 데이터가 직접 넘어오는 경우
  - `@RequestParam, @ModelAttribute` 사용 불가
  - (물론 HTML Form 으로 전달되는 경우는 가능)



**RequestBodyStringController**

```java
package hello.springmvc.basic.request;

import jakarta.servlet.ServletInputStream;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;

import java.io.IOException;
import java.nio.charset.StandardCharsets;

@Slf4j
@Controller
public class RequestBodyStringController {

    @PostMapping("/request-body-string-v1")
    public void requestBodyString(HttpServletRequest request,
                                  HttpServletResponse response) throws IOException {

        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("messageBody = {}", messageBody);

        response.getWriter().write("ok");
    }
}

```

- `String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);`
  - byteCode :arrow_right: String 변환 : 이렇게 변환 시에는 꼭 인코딩 방식 명시해줘야 함



**Input, Output 스트림, Reader - requestBodyStringV2**

```java
    /**
     * InputStream(Reader): HTTP 요청 메시지 바디의 내용을 직접 조회
     * OutputStream(Writer): HTTP 응답 메시지의 바디에 직접 결과 출력
     */
    @PostMapping("/request-body-string-v2")
    public void requestBodyStringV2(InputStream inputStream, Writer responseWriter) throws IOException {
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
        log.info("messageBody={}", messageBody);
        responseWriter.write("ok");
    }
```

- `InputStream(Reader)` : HTTP 요청 메시지 바디의 내용을 직접 조회 가능
- `OutputStream(Writer)` : HTTP 응답 메시지의 바디에 직접 결과 출력



**HttpEntity - requestBodyStringV3**

```java
    /**
     * HttpEntity: HTTP header, body 정보를 편리하게 조회
     * - 메시지 바디 정보를 직접 조회(@RequestParam X, @ModelAttribute X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     *
     * 응답에서도 HttpEntity 사용 가능
     * - 메시지 바디 정보 직접 반환(view 조회X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     */
    @PostMapping("/request-body-string-v3")
    public HttpEntity<String> requestBodyStringV3(HttpEntity<String> httpEntity) {
        String messageBody = httpEntity.getBody();
        log.info("messageBody={}", messageBody);
        return new HttpEntity<>("ok");
    }
```

- HttpEntity : HTTP header, body 정보 편리하게 조회
  - 메시지 바디 정보 직접 조회
  - **:star: 요청 파라미터를 조회하는 기능과 관련 없음. `@RequestParam` X, `@ModelAttribute` X**

- HttpEntity 는 응답에도 사용 가능
  - 메시지 바디 정보 직접 반환
  - 헤더 정보 포함 가능
  - view 조회 X
- HttpEntity 상속받은 아래 객체들도 같은 기능 제공
  - RequestEntity
  - ResponseEntity : HTTP 상태 코드 설정 가능, 응답에서 사용
    - `return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED)`



**@RequestBody - requestBodyStringV4**

```java
    /**
     * @RequestBody
     * - 메시지 바디 정보를 직접 조회(@RequestParam X, @ModelAttribute X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     *
     * @ResponseBody
     * - 메시지 바디 정보 직접 반환(view 조회X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     */
    @ResponseBody
    @PostMapping("/request-body-string-v4")
    public String requestBodyStringV4(@RequestBody String messageBody) {
        log.info("messageBody={}", messageBody);
        return "ok";
    }
```

`@RequestBody`

- 이를 사용하면 HTTP 메시지 바디 정보 편리하게 조회 가능
- 헤더 정보가 필요하다면 HttpEntity 사용 or `@RequestHeader` 사용



**:warning: 요청 파라미터 vs HTTP 메시지 바디 :warning:**

- 요청 파라미터를 조회하는 기능 : `@RequestParam`, `@ModelAttribute`
- HTTP 메시지 바디를 직접 조회하는 기능 : `@RequestBody`
  - HTTP 메시지 컨버터라는 전혀 다른 메커니즘 동작!



#### [요청 파라미터] JSON



**RequestBodyJsonController**

```java
package hello.springmvc.basic.request;

import com.fasterxml.jackson.databind.ObjectMapper;
import hello.springmvc.basic.HelloData;
import jakarta.servlet.ServletInputStream;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.PostMapping;

import java.io.IOException;
import java.nio.charset.StandardCharsets;

/**
 * {"username":"hello", "age":20}
 * content-type: application/json
 */
@Slf4j
@Controller
public class RequestBodyJsonController {

    // json 일 때 필요
    private ObjectMapper objectMapper = new ObjectMapper();

    @PostMapping("/request-body-json-v1")
    public void requestBodyJsonV1(HttpServletRequest request,
                                  HttpServletResponse response) throws IOException {

        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("messageBody={}", messageBody);
        HelloData data = objectMapper.readValue(messageBody, HelloData.class);
        log.info("username={}, age={}", data.getUsername(), data.getAge());

        response.getWriter().write("ok");
    }
}

```

- HttpServletRequest 를 사용해서 직접 HTTP 메시지 바디에서 데이터 읽어와서, 문자로 변환
- 문자로된 JSON 데이터를 Jackson 라이브러리인 objectMapper 를 사용해 자바 객체로 변환



**requestBodyJsonV2 - @RequestBody 문자 변환**

```java
    /**
     * @RequestBody
     * HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     *
     * @ResponseBody
     * - 모든 메서드에 @ResponseBody 적용
     * - 메시지 바디 정보 직접 반환(view 조회X)
     * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
     */
    @ResponseBody
    @PostMapping("/request-body-json-v2")
    public String requestBodyJsonV2(@RequestBody String messageBody) throws
            IOException {
        HelloData data = objectMapper.readValue(messageBody, HelloData.class);
        log.info("username={}, age={}", data.getUsername(), data.getAge());
        return "ok";
    }
```

- @RequestBody 로 HTTP 메시지에서 데이터 꺼내고 messageBody 에 저장
- 문자로된 JSON 데이터인 messageBody 를 objectMapper 를 통해 자바 객체로 변환



**requestBodyJsonV3 - @RequestBody 객체 변환**

```java
    /**
     * @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림)
     * HttpMessageConverter 사용
     * -> MappingJackson2HttpMessageConverter (content-type: application/json)
     */
    @ResponseBody
    @PostMapping("/request-body-json-v3")
    public String requestBodyJsonV3(@RequestBody HelloData data) {
        log.info("username={}, age={}", data.getUsername(), data.getAge());
        return "ok";
    }
```

- `@RequestBody HelloData data`
  - 직접 만든 객체를 지정해서 바인딩할 수 있다.

- `@RequestBody` 는 생략 불가능

  :repeat: [복습] @ModelAttribute, @RequestParam 과 같은 애노테이션을 생략시 다음과 규칙 적용

  String , int , Integer 같은 단순 타입 = @RequestParam

  나머지 = @ModelAttribute (argument resolver 로 지정해둔 타입 외)

  - 생략하면 HTTP 메시지 바디가 아니라 요청 파라미터를 처리하게 됨(@ModelAttribute 가 적용)



주의!

- HTTP 요청시에 content-type 이 application/json 인지 꼭! 확인

​	: 그래야 JSON 처리할 수 있는 HTTP 메시지 컨버터가 실행



**requestBodyJsonV4 - HttpEntity**

```java
    @ResponseBody
    @PostMapping("/request-body-json-v4")
    public String requestBodyJsonV4(HttpEntity<HelloData> httpEntity) {
        HelloData data = httpEntity.getBody();
        log.info("username={}, age={}", data.getUsername(), data.getAge());
        return "ok";
    }
```



**requestBodyJsonV5**

```java
    /**
     * @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림)
     * HttpMessageConverter 사용
     * -> MappingJackson2HttpMessageConverter (content-type: application/json)
     *
     * @ResponseBody 적용
     * - 메시지 바디 정보 직접 반환(view 조회X)
     * - HttpMessageConverter 사용
     * -> MappingJackson2HttpMessageConverter 적용(Accept: application/json)
     */
    @ResponseBody
    @PostMapping("/request-body-json-v5")
    public HelloData requestBodyJsonV5(@RequestBody HelloData data) {
        log.info("username={}, age={}", data.getUsername(), data.getAge());
        return data;
    }
```

- Accept 는 Client 가 받는 응답 타입을 지정해주는 것
  - 위의 주석에서는 json 으로 나가야 할 때 체크해주는 것
- `@RequestBody` 요청
  - JSON 요청 :arrow_right: HTTP 메시지 컨버터 :arrow_right: 객체
- `@ResponseBody` 
  - 객체 :arrow_right: HTTP 메시지 컨버터 :arrow_right: JSON 응답

## HTTP 응답

**응답 데이터 만드는 방법 3가지**

1. 정적 리소스

   예) 웹 브라우저에 정적인 HTML, css, js 를 제공할 때 정적 리소스 사용

2. 뷰 템플릿 사용

   예) 웹 브라우저에 동적인 HTML 을 제공할 때는 뷰 템플릿 사용

3. HTTP 메시지 사용

   HTTP API 를 제공하는 경우, HTML 이 아니라 데이터를 전달해야 하므로, HTTP 메시지 바디에 JSON 같은 형식으로 데이터 실어 보냄

### 정적 리소스, 뷰 템플릿

- 스프링 부트는 클래스패스의 다음 디렉토리에 있는 정적 리소스 제공

  `/static`, `/public`, `/resources`, `/META-INF/resources`

- `src/main/resources` 는 리소스를 보관하는 곳이고, 클래스패스의 시작 경로

  - 따라서 다음 디렉토리에 리소스를 넣어두면 스프링 부트가 정적 리소스로 서비스 제공

**정적 리소스 경로**

- `src/main/resources/static`
  - 정적으로 스프링 부트가 내장 tomcat 을 통해서 자동으로 서빙해줌
- 다음 경로에 파일이 들어있으면
  - `src/main/resources/static/basic/hello-form.html`
- 웹 브라우저에 다음과 같이 실행하면 됨
  - `http://localhost:8080/basic/hello-form.html`
  - 정적 리소스는 해당 파일을 변경 없이 그대로 서비스하는 것

**뷰 템플릿**

- 뷰 템플릿을 거쳐서 HTML 이 생성되고, 뷰가 응답을 만들어서 전달
- 일반적으로 HTML 을 동적으로 생성하는 용도로 사용
- 스프링 부트 기본 뷰 템플릿 경로 : `src/main/resources/templates`

**뷰 템플릿 생성**

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p th:text="${data}">empty</p>
</body>
</html>
```

**ResponseViewController - 뷰 템플릿을 호출하는 컨트롤러**

```java
package hello.springmvc.basic.response;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class ResponseViewController {

    @RequestMapping("/response-view-v1")
    public ModelAndView responseViewV1() {
        ModelAndView mav = new ModelAndView("response/hello").addObject("data", "hello! v1");
        return mav;
    }

    @RequestMapping("/response-view-v2")
    public String responseViewV2(Model model) {
        model.addAttribute("data", "hello!! v2");
        return "response/hello";
    }

    // 절대 권장 X, 너무 불명확함
    @RequestMapping("/response/hello")
    public void responseViewV3(Model model) {
        model.addAttribute("data", "hello!! v3");
    }

}
```

**String 을 반환하는 경우 - View or HTTP 메시지**

- `@ResponseBody` 가 없으면 response/hello 로 뷰 리졸버가 실행되어 뷰를 찾고, 렌더링
- `@ResponseBody` 가 있으면 뷰 리졸버를 실행하지 않고, HTTP 메시지 바디에 직접 response/hello 라는 문자가 입력됨

- 여기서는 뷰의 논리 이름인 response/hello 를 반환하면 다음 경로의 뷰 템플릿이 렌더링 됨
  - 실행 : `templates/response/hello.html`

**Void 를 반환하는 경우**

- `@Controller` 를 사용, HttpServletResponse, OutputStream(Writer) 같은 HTTP 메시지 바디를 처리하는 파라미터가 없으면 **요청 URL 을 참고해서 논리 뷰 이름으로 사용**
  - 요청 URL : /response/hello
  - 실행 : templates/response/hello.html
- 이 방식은 명시성이 떨어지고, 딱 맞는 경우도 없어서 권장 X

**HTTP 메시지**

- `@ResponseBody`, `HttpEntity` 를 사용하면, 뷰 템플릿을 사용하는 것이 아니라, HTTP 메시지 바디에 직접 응답하는 데이터를 출력할 수 있다.

> Thymeleaf 스프링 부트 설정
>
> 스프링 부트가 자동으로 ThymeleafViewResolver 와 필요한 스프링 빈들을 등록
>
> 그리고 다음 설정도 사용, 이 설정은 기본 값이기 때문에 변경이 필요할 때만 설정하면 됨
>
> ```properties
> spring.thymeleaf.prefix=classpath:/tmeplates/
> spring.thymeleaf.suffix=.html
> ```

### HTTP API, 메시지 바디에 직접 입력

- HTTP API 를 제공하는 경우에는 HTML 이 아니라 데이터를 전달해야 함
  - HTTP 메시지 바디에 JSON 형식으로 데이터를 실어 보냄

> 참고
>
> HTML 이나 뷰 템플릿을 사용해도 HTTP 응답 메시지 바디에 데이터가 담겨서 전달됨
>
> 여기서는 정적 리소스나, 뷰 템플릿을 거치지 않고, 직접 HTTP 응답 메시지를 전달하는 경우

**ResponseBodyController**

```java
package hello.springmvc.basic.response;

import hello.springmvc.basic.HelloData;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

import java.io.IOException;

@Slf4j
@Controller
public class ResponseBodyController {
    @GetMapping("/response-body-string-v1")
    public void responseBodyV1(HttpServletResponse response) throws IOException {
        response.getWriter().write("ok");
    }

    /**
     * HttpEntity, ResponseEntity(Http Status 추가)
     * @return
     */
    @GetMapping("/response-body-string-v2")
    public ResponseEntity<String> responseBodyV2() {
        return new ResponseEntity<>("ok", HttpStatus.OK);
    }

    @ResponseBody
    @GetMapping("/response-body-string-v3")
    public String responseBodyV3() {
        return "ok";
    }

    @GetMapping("/response-body-json-v1")
    public ResponseEntity<HelloData> responseBodyJsonV1() {
        HelloData helloData = new HelloData();
        helloData.setUsername("userA");
        helloData.setAge(20);

        return new ResponseEntity<>(helloData, HttpStatus.OK);
    }

    // 주로 이걸 사용
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    @GetMapping("/response-body-json-v2")
    public HelloData responseBodyJsonV2() {
        HelloData helloData = new HelloData();
        helloData.setUsername("userA");
        helloData.setAge(20);

        return helloData;
    }
}
```

**responseBodyV1**

- 서블릿 직접 다룰 때 처럼

**responseBodyV2**

- ResponseEntity 는 HttpEntity 를 상속받음
- 그래서 HTTP 응답 코드를 설정할 수 있음

**responseBodyV3**

- @ResponseBody 를 사용하면 view 사용하지 않고, HTTP 메시지 컨버터로 HTTP 메시지 직접 입력 가능
- ResponseEntity 도 동일한 방식으로 동작

**responseBodyJsonV1**

- ResponseEntity 반환, HTTP 메시지 컨버터로 JSON 형식으로 변환되어 반환

**responseBodyJsonV2**

- ResponseEntity 는 HTTP 응답 코드 설정 가능
- @ResponseBody 를 사용하면 HTTP 응답 코드 등을 사용하기 까다로움
- 그래서 @ResponseStatus(HttpStatus.OK) 애노테이션 사용하면 응답 코드 설정 가능
  - 그러나 애노테이션이기 때문에 응답 코드를 동적으로 변경할 수 X
  - 프로그램 조건에 따라서 동적으로 변경하려면 ResponseEntity 를 사용하면 됨

**@RestController**

- 해당 컨트롤러에 모두 @ResponseBody 가 적용되는 효과
- 뷰 템플릿을 사용하는 것이 아니라 HTTP 메시지 바디에 직접 데이터를 입력하는 것
- 이름 그대로 RestAPI 를 만들 때 사용하는 컨트롤러

## HTTP 메시지 컨버터

- HTTP API 처럼 JSON 데이터를 HTTP 메시지 바디에서 직접 읽거나 쓰는 경우 HTTP 메시지 컨버터를 사용하면 편리!

### `@ResponseBody` 사용 원리

1. 웹 브라우저가 요청

2. Controller 호출

3. `@ResponseBody` 애노테이션이 있으면

4. viewResolver 대신에 `HttpMessageConverter` 가 동작

   - HttpMessageConverter 구현체 대표적으로 두 개 존재

     StringHttpMessageConverter : 기본 문자 처리

     MappingJackson2HttpMessageConverter : 기본 객체 처리

5. 그리고 다시 응답

Controller 가 호출되기 전에 HTTP 메시지 컨버터가 적용되어서 RequestBody/ResponseBody 가 있으면 HttpMessageBody 의 데이터를 꺼내서 변환 후 객체/문자 넘겨주는 것

> 참고 : 응답의 경우 클라이언트의 HTTP Accept 헤더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서 `HttpMessageConverter` 구현체가 선택된다.

스프링 MVC 는 다음과 같은 경우에 HTTP 메시지 컨버터 적용

- HTTP 요청 : `@RequestBody`, `HttpEntity(RequestEntity)`
- HTTP 응답 : `@ResponseBody`, `HttpEntity(ResponseEntity)`

![image-20240929125355751]({{site.url}}/images/2024-09-22-springmvc(6)/image-20240929125355751.png)

HTTP 메시지 컨버터는 HTTP 요청/응답 둘 다 사용

- canRead(), canWrite() : 메시지 컨버터가 해당 클래스, 미디어 타입을 지원하는지 체크
- read(), write() : 메시지 컨버터를 통해서 메시지를 읽고 쓰는 기능

**스프링 부트 기본 메시지 컨버터**

```
0 = ByteArrayHttpMessageConverter
1 = StringHttpMessageConverter
2 = MappingJackson2HttpMessageConverter
```

- 스프링 부트는 다양한 메시지 컨버터 제공하는데, 대상 클래스 타입과 미디어 타입(Content-Type) 둘을 체크해서 사용 여부 결정
- 만족하지 않으면 다음 메시지 컨버터로 우선순위 넘어감

1. ByteArrayHttpMessageConverter : byte[] 데이터 처리
   - 클래스 타입 : byte[], 미디어 타입 : \*/\* (아무 미디어 타입 가능)
   - 요청 예) `@ResponseBody byte[] data`
   - 응답 예) `@ResponseBody return byte[]`, 쓰기 미디어타입 `application/octet-stream`(Http 응답 헤더에 자동으로 들어감)
2. StringHttpMessageConverter : String 문자로 데이터 처리
   - 클래스 타입 : String, 미디어 타입 : \*/\*
   - 예)
     - 요청 : `@RequestBody String data`
     - 응답 : `@ResponseBody return "ok"`, 쓰기 미디어 타입 `text/plain`
3. MappingJackson2HttpMessageConverter : application/json 관련
   - 클래스 타입 : 객체 또는 HashMap, 미디어타입 `application/json`
   - 예)
     - 요청 : `@RquestBody HelloData data`
     - 응답 : `@ResponseBody return helloData`, 쓰기 미디어 타입 `application/json` 관련

### HTTP 메시지 컨버터 작동 예시

**StringHttpMessageConverter**

```java
content-type: application/json

@RequestMapping
void hello(@RequestBody String data) {}
```

HTTP 메시지 컨버터 중에 맞는 거 찾기



1. Byte 인지 체크 : @RequestBody String : X
2. String 인지 체크 : @RequestBody String : O
   - Media-Type : json, 미디어 타입 \*/\* 모두 허용이므로 O



**MappingJackson2HttpMessageConverter**

```java
content-type: application/json

@RequestMapping
void hello(@RequestBody HelloData data) {}
```

HTTP 메시지 컨버터 중에 맞는 거 찾기



1. Byte, String 인지 체크 : @RequestBody HelloData : X
2. 객체 or HashMap 인지 체크 : @RequestBody HelloData : O
   - Media-Type : json, 미디어 타입 application/json 허용 이므로 O



**?**

```java
content-type: text/html

@RequestMapping
void hello(@RequestBody HelloData data) {}
```

HTTP 메시지 컨버터 중에 맞는 거 찾기



1. Byte, String 인지 체크 : @RequestBody HelloData : X
2. 객체 or HashMap 인지 체크 : @RequestBody HelloData : O
   - Media-Type : text/html, 미디어 타입 application/json 허용 이므로 X : 오류 발생



### HTTP 요청 데이터 읽기

- HTTP 요청이 오고, 컨트롤러에서 `@RequestBody`, `HttpEntity` 파라미터 사용
- 메시지 컨버터가 메시지 읽을 수 있는지 확인 : `canRead()` 호출
  - 대상 클래스 타입 지원하는가
  - **HTTP 요청의 Content-Type 미디어 타입 지원하는가**
- canRead() 조건 만족하면 read() 호출해서 객체 생성하고, 반환

### HTTP 응답 데이터 생성

- 컨트롤러에서 `@ResponseBody`, `HttpEntity` 로 값 반환
- 메시지 컨버터가 메시지를 쓸 수 있는지 확인 : `canWrite()` 호출
  - 대상 클래스 타입을 지원하는가
  - **HTTP 요청의 Accept 미디어 타입을 지원하는가**.(정확히 `@RequestMapping` 의 produces)
- cnaWrite() 조건을 만족하면 wrtie() 호출해서 HTTP 응답 메시지 바디에 데이터 생성

## 요청 매핑 핸들러 어댑터 구조

- HTTP 메시지 컨버터는 스프링 MVC 어디쯤에서 사용되는 것?

  비밀은 애노테이션 기반의 컨트롤러, `@RequestMapping`을 처리하는 핸들러 어댑터인 `RequestMappingHandlerAdapter`(요청 매핑 핸들러 어댑터)에 있다.

### RequestMappingHandlerAdapter 동작 방식

![image-20240929144121808]({{site.url}}/images/2024-09-22-springmvc(6)/image-20240929144121808.png)

0. **RequestMappingHandlerAdapter** 가 **ArgumentResolver** 호출
   - RequestMapping 핸들러 어댑터가 ArgumentResolver 에게 물어봄
   - Controller 매개변수에 맞춰서 HttpServletRequest 객체 가져다 줄 수 있어?
1. 컨트롤러의 파라미터, 애노티에션 정보를 기반으로 전달 데이터 생성
   - HttpServletRequest, Model, @RequestParam, @ModelAttribute, @RequestBody, HttpEntity ...
   - 컨트롤러를 호출하려면, Controller 로 넘어가는 매개변수, 전달 데이터를 넘겨줘야 함
   - @RequestParam 등 애노테이션을 보고 로직을 처리해서 파라미터로 전달해야 함
   - 알맞게 데이터를 생성해서 넘겨주는 과정이 필요
2. ArgumentResolver 가 알맞은 데이터를 생성해서 RequestMappingHandlerAdapter 에 넘겨주면, RequestMappingHandlerAdapter 는 알맞은 핸들러 찾아서 알맞은 데이터 찾아서 넘겨줌
3. 컨트롤러의 반환 값을 변환
   - ModelAndView, @ResponseBody, HttpEntity
   - Controller 에서 다양한 타입으로 반환하는데, 이걸 처리하는 것. Converting 작업을 해주는 것



**ArgumentResolver**

- 애노테이션 기반의 컨트롤러의 매우 다양한 파라미터를 사용할 수 있음
  - HttpServletRequest, Model, @RequestParam, @ModelAttribute, @RequestBody, HttpEntity 모두 사용 가능
  - 매우 큰 유연함을 가지는데, 파라미터를 유연하게 처리할 수 있는가 바로 **ArgumentResolver** 덕분
- 애노테이션 기반 컨트롤러를 처리하는 `RequestMappingHandlerAdapter` 는 바로 `ArgumentResolver` 를 호출해서 컨트롤러(핸들러)가 필요로 한느 다양한 파라미터의 값(객체)을 생성
- 이렇게 파라미터의 값이 모두 준비되면 컨트롤러를 호출하면서 값을 넘겨줌

`HandlerMethodArgumentResolver` 인데, 줄여서 `ArgumentResolver` 라고 부름

![image-20240929151003902]({{site.url}}/images/2024-09-22-springmvc(6)/image-20240929151003902.png)



**동작 방식**

1. ArgumentResolver 의 `supportsParameter()` 를 호출해서 해당 파라미터를 지원하는지 체크하고, 지원하면 `resolveArguemtn()` 를 호출해서 실제 객체 생성
2. 이렇게 생성된 객체가 컨트롤러 호출시 넘어가는 것(다형성 활용하여 잘 설계한 것)

- 그리고 원한다면 이 인터페이스를 확장해서 ArgumentResolver 를 만들 수 있음
  - 실제 확장하는 예제는 로그인 처리에서 진행



**ReturnValueHandler**(3번 역할을 하는 존재)

- `HandlerMethodReturnValueHandler` 를 줄여서 `ReturnValueHandler` 라 부름
- **`ArgumentResolver` 와 비슷한데, 이것은 응답 값을 변환하고 처리**
- 컨트롤러에서 String 으로 뷰 이름을 반환해도, 동작하는 이유가 바로 ReturnValueHandler 덕분

![image-20240929151402631]({{site.url}}/images/2024-09-22-springmvc(6)/image-20240929151402631.png)

![image-20240929151436918]({{site.url}}/images/2024-09-22-springmvc(6)/image-20240929151436918.png)

위의 목록처럼 구현체가 약 19개 존재한다.



### **HTTP 메시지 컨버터 위치**

![image-20240929151629887]({{site.url}}/images/2024-09-22-springmvc(6)/image-20240929151629887.png)

- (요청) @RequestBody 도 컨트롤러가 필요로 하는 파라미터의 값에 사용
  - 즉 파라미터를 처리해서 넘겨주는 ArgumentResolver 가 사용하고 있는 것
  - @RequestBody 를 처리하는 ArgumentResolver 가 있고, HttpEntity 를 처리하는 ArgumentResolver 가 있음
  - ArgumentResolver 들이 HTTP 메시지 컨버터를 사용해서 필요한 객체를 생성(read)하는 것
  - ArgumentResolver 들이 HTTP Message Converter 를 루프로 돌리면서 요청 데이터 생성 처리하는 것
- (응답) @ResponseBody 의 경우도 컨트롤러 반환 값 이용
  - 즉 반환 값을 처리해서 응답하는 ReturnValueHandler 가 사용하고 있는 것
  - @ResponseBody 와 HttpEntity 를 처리하는 ReturnValueHandler 존재. 여기에서 HTTP 메시지 컨버터를 호출(write)해서 응답 결과 만드는 것
  - ReturnValueHandler 들이 HTTP Message Converter 를 루프로 돌리면서 응답 데이터 생성 처리하는 것
- 스프링 MVC 는 @RequestBody, @ResponseBody 가 있으면 RequestResponseBodyMethodProcessor(), HttpEntity 가 있으면 HttpEntityMethodProcessor() 사용



### 확장

스프링은 다음 모두를 인터페이스로 제공

- HandlerMethodArgumentResolver
- HandlerMethodReturnValueHandler
- HttpMessageConverter

실제 기능을 확장할 일이 많지는 않지만, 기능 확장은 WebMvcConfigurer 를 상속 받아서 스프링 빈으로 등록하면 됨

자주 사용하지는 않으니 실제 기능 확장이 필요할 때 **WebMvcConfigurer** 를 검색해보기



---
출처 : https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1