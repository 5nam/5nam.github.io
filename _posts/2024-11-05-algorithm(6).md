---
layout: single
title:  "[ALGORITHM STUDY] 완전탐색 (For 반복문)"
published : true
categories: algorithm
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

## 문제 1) 백준 1816

![image-20241105122502389]({{site.url}}/images/2024-11-05-algorithm(6)/image-20241105122502389.png)

- 소인수 : 주어진 자연수를 나누어 떨어뜨리는 약수 중에서 소수인 약수
- 소수 : 1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수

### 시간초과 코드(완전탐색)

```java
package java_coding_test;

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long[] S = new long[n];

        for(int i = 0; i<n; i++) {
            S[i] = sc.nextLong();
        }

        for(int i = 0; i<n; i++) {
            if(solution(S[i])) {
                System.out.println("YES");
                continue;
            }
            System.out.println("NO");
        }

        sc.close();
    }

    public static boolean solution(long num) {
        boolean temp = true;
        for(long j = 2; j < num; j++) {
            if(num % j == 0) {
                if(j >= 1000000) {
                    System.out.println(j);
                    break;
                }
                temp = false;
                break;
            }
        }

        return temp;
    }
}
```

### 문제 분석

- 100만보다 작고 2 이상의 약수를 가지고 있다면, 틀린 비밀번호가 되는 것

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long[] S = new long[n];

        for(int i = 0; i<n; i++) {
            S[i] = sc.nextLong();
        }

        for(int i = 0; i<n; i++) {
            for(long j = 2; j<1000001; j++) {
                if(S[i]%j == 0) {
                    // 100만 이하의 약수가 존재한다
                    System.out.println("NO");
                    break;
                }
                if (j == 1000000) {
                    // 100만 이하의 약수가 존재하지 않는다
                    System.out.println("YES");
                }
            }
        }  

        sc.close();
    }
}
```

- **앞으로 만나게 될 모든 문제를 일단! 완전탐색, 모든 경우의 수를 넣어줄 것**

- 문제를 만났을 때 기술이나 아이디어를 찾으려고 하면, 모르는 기술, 모르는 아이디어가 필요한 문제는 푸는 것이 가능할까?
  - 어떤 문제든지 경우의 수가 보인다면 시간과 메모리가 충분히 주어진다면 완전 탐색으로 그 문제를 해결할 수 있음
  - 어떤 문제라고 해도 시간, 메모리만 충분하면 그 문제를 해결할 수 있게 되는 것

:star: **(약속) 수업을 진행하는 동안에는 어떤 문제를 만나더라도 반드시 완전탐색적으로 생각해서 첫번째 코드를 짜겠다!**

## 문제 2) 백준 #14568

