---
title:  "[DATA STRUCTURE] 리스트"
categories: data_structure
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

## 리스트

### 리스트 ADT

#### 리스트의 개념

- 리스트는 목록 형태로 이뤄진 데이터 형식
- 리스트의 목록을 이루는 개별 요소를 노드라고 부름
  - 리스트의 첫 번째 노드 : 헤드(head)
  - 리스트의 마지막 노드 : 테일(tail)
- 리스트가 갖춰야 할 일련의 연산
  - 리스트에 노드를 추가하는 연산(append)
  - 노드 사이에 노드를 삽입하는 연산(insert)
  - 노드를 제거하는 연산(remove)
  - 특정 위치에 있는 노드를 반환하는 연산(getAt)

### 리스트와 배열 비교

- 배열은 리스트처럼 데이터 목록을 다루고, C 언어에서 기본적으로 제공
- 근데 왜 배열이 아닌 리스트를 사용할까?
  - 배열은 생성하는 시점에 반드시 배열의 크기를 지정해줘야 하고, 생성한 후에 그 크기를 변경할 수 없다는 단점 존재
- 그래서 배열처럼 데이터 집합 보관 기능을 가지면서도 배열과 달리 유연하게 크기를 바꿀 수 있는 자료구조인 리스트를 활용하는 것
- 리스트는 간단하고, 활용도가 높고, 스택과 큐, 트리와 같은 자료구조를 이해하는 기반이 된다는 점에서 중요

### 링크드 리스트

- 노드를 연결해서 만든 리스트

- 링크드 리스트의 노드 구성요소

  - 데이터를 보관하는 필드
  - 다음 노드와 연결 고리 역할을 하는 포인터

- 이 노드들을 엮으면 링크드 리스트가 되는 것

  <img src="{{site.url}}/assets/images/2024-09-25-datastructure(2)/image-20240925214051920.png" alt="image-20240925214051920"  />

- 다뤄야 하는 데이터 집합의 크기를 미리 알지 못해도 데이터가 늘어날 때마다 노드를 만들어 테일에 붙이면 됨
  - 붙인 노드는 새로운 테일이 되고 이전에 테일이었던 노드는 평범한 노드가 됨
- 리스트 사이에 새로운 노드를 끼워 넣거나 제거하기도 아주 쉬움
  - 해당 노드를 가리키는 포인터만 교환하면 되므로

### 링크드 리스트의 노드 표현

링크드 리스트의 노드 C언어로 표현

```c
typedef int ElementType;

typedef struct tagNode
{
		ElementType Data; // 데이터
		struct Node* NextNode; // 다음 노드 
} Node;
```

ElementType 은 언제든 공부한 후 바꿔서 사용하면 됨

### 링크드 리스트의 주요 연산

- 링크드 리스트에는 두 종류의 연산이 필요

  1. 자료구조를 구축하기 위한 연산
  2. 자료구조에 저장된 데이터를 활용하기 위한 연산

- 종류

  - 노드 생성(CreateNode) / 소멸(DestroyNode)
  - 노드 추가(AppendNode)
  - 노드 탐색(GetNodeAt)
  - 노드 삭제(RemoveNode)
  - 노드 삽입(InsertAfter, InsertNewHead)

- 노드 생성/소멸, 추가, 삭제, 삽입은 링크드 리스트 자료구조를 구축하기 위한 연산

  > 노드 소멸과 노드 삭제는 완전히 다른 연산
  >
  > 노드 소멸은 노드를 메모리에서 없애는 연산을 말하고, 노드 삭제는 리스트에서 노드를 제외하는 연산

- 탐색은 구축된 링크드 리스트의 데이터를 활용하기 위한 연산

- 링크드 리스트는 '기만적 단순함' 의 경우와 비슷함. 단순해 보여도 우아한 자료구조로 유지하려면 여섯 가지 연산을 구현할 때 자유 저장소와 포인터를 잘 사용해야 함

#### 노드 생성/소멸 연산

- 세 가지 메모리 영역
  1. 전역 변수와 정적 변수 등이 저장되는 **정적 메모리** 
  2. 자동으로 메모리를 해제하는 **자동 메모리**
  3. 자유롭게 데이터를 할당해서 사용하는 **자유 저장소**

- 먼저 **자동 메모리**를 사용하는 방안 봐보자

  ```c
  Node* SSL_CreateNode( ElementType NewData )
  {
          Node NewNode; // 자동 메모리에 새로운 노드 생성
          NewNode.Data = NewData;
          NewNode.NextNode = NULL;
  
          return &newNode; // NewNode 가 생성된 메모리의 주소를 반환
          // 함수가 종료되면서 NewNode 는 자동 메모리에서 제거
  }
  
  Node* MyNode = SLL_CreateNode( 117 ); // MyNode 는 할당되지 않은 메모리를 가리킨다.
  ```

  - SLL_CreateNode() 함수가 가장 먼저 지역 변수 NewNode 를 자동 메모리(스택)에 생성하고 NewData 의 Data, NextNode 필드를 초기화. 그리고 함수 끝에서 NewNode 의 주소를 반환

  문제는 return 문이 실행된 후에 벌어짐

  - MyNode 포인터는 NewNode 가 '존재하는' 메모리의 주소를 가지는게 아님
  - 자동 메모리에 의해 제거된 NewNode 가 '존재했던' 메모리의 주소를 담고 있음
  - 즉, 이미 사라져버린 NewNode 의 주소를 담고 있는 포인터 때문에 프로그램이 죽어버리거나, 예기치 않은 동작을 야기하는 사고뭉치가 되는 것

- 이제 노드 생성에 자동 메모리가 적합하지 않다는 것을 알았음. 남은 선택지는 **자유 저장소**

  ```c
  void* malloc(size_t size);
  ```

  - 반환 형식 : `void*` ➡️ 모든 형식의 메모리를 가리킬 수 있는 만능 포인터
  - malloc() 은 얼마나 큰 공간을 할당할지를 다루는 함수, 그 안에는 어떤 데이터 형식이 담기는지는 관심이 없으므로 void* 는 함수가 할당하는 자유 저장소의 메모리 주소를 가리키기에 적합한 형식
  - malloc() 의 매개 변수 size 하나. size 는 malloc() 이 할당해야 하는 메모리의 크기를 나타냄