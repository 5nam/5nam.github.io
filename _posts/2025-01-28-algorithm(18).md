---
title:  "[ALGORITHM STUDY] 다이나믹 프로그래밍 [문제풀이] : 11048"
published : true
categories: algorithm
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true
---

# 다이나믹 프로그래밍(DP) 알고리즘 [제대로 이해하기]

## DP 알고리즘

- 재귀적인 구조(관계식)을 찾아 문제를 효율적으로 해결하는 알고리즘
    - 그래서 재귀적인 구조를 찾는 것이 중요
- 내가 생각한 DP 알고리즘이 타당한지 판단하는 법
  
    **1️⃣ DP 관계식이 타당한지 판단**
    
    - DP Table의 정의에 대해 DP 관계식이 논리에 오류가 없어야 한다.
    
    **2️⃣ 초기값을 구할 수 있는지에 대한 판단**
    
    - DP Table의 초기값을 구할 수 있어야 한다.
- DP 알고리즘의 시간 복잡도 계산
  
    ⇒ `DP Table 의 크기` + `한 번 갱신하는 데 걸리는 연산`
    

### 문제로 살펴보기 : 백준 11048

아래 순서로 접근하는 것이 좋음

- 브루트포스
    - 모든 경우를 탐색하는 방법 : 최대 $O(3^{1000})$
    - 시간초과
- 그리디
    - 현재 가장 높은 원소를 선택하는 방법 ≠ 최적해
    
    예)
    
    ```python
    3 4
    1 2 3 4
    0 0 0 5
    9 8 7 6
    ```
    
    - 현재 가장 높은 원소 선택
      
        1 → 2 → 3 → 4 → 5 → 6 ≠ 최적해
        

**DP**

1. DP 테이블 설계
    - dp\[r\]\[c\] : (r, c)에 도달했을 때의 최대값
    - `dp[r][c]` = `max(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + arr[r][c]`
    
    **[DP 관계식에 대한 판단]**
    
    - 여기서 dp\[r\]\[c\] 를 (r, c)에 도달했을 때의 최대값이라고 하면
    - `dp[r][c]` = `max(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + arr[r][c]` 는 올바른 식이다!
    - 예) 3x3 에서 (3,3)을 구할 때, 올 수 있는 경로가 🟢 가 있는 3곳이다. 그럼 결국 (2,3) - (3,2) - (2,2) 경로 중 가장 최대인 값으로 온 것을 택하면 되는 것
        - 위의 `dp[r][c]` = `max(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + arr[r][c]` 가 만족한다.
        
        |  |  |  |
        | --- | --- | --- |
        |  | 🟢 | 🟢 |
        |  | 🟢 |  |
2. 초기값을 구할 수 있는지에 대한 판단
- dp\[r\]\[c\] 를 갱신하기 위해서는 dp\[r-1\]\[c\], dp\[r\]\[c-1\], dp\[r-1\]\[c-1\] 에 올바른 값이 있어야 하고, 접근 가능해야 한다.
- 그럼 가장 위의 줄과, 가장 왼쪽 줄이 0으로 초기화되어 있으면 된다!
  
    예) 3x3 에서 🟢(1,1) 을 구하려면 🔷(0,1), 🔷(1,0), 🔷(0,0) 이 필요하다. 이를 위해 두 가지 방법이 있다.
    
    1. 0행 부분과 0열 부분을 모두 0으로 초기화한다.
    2. 1행 부분과 1열 부분을 모두 입력받은 arr 값을 참고하여 초기화해준다.
    
    | 🔷 | 🔷 |  |  |
    | --- | --- | --- | --- |
    | 🔷 | 🟢 |  |  |
    |  |  |  |  |
    |  |  |  |  |

결국, DP 관계식도 타당하고, 초기값을 구할 수 있으므로 DP 풀이로 풀 수 있다!

1. 시간 복잡도 계산
- DP Table 의 크기 x 한 번 갱신하는 데 걸리는 연산
- $1000 \times 1000\times3=300만$
- $O(NM)$

## DP 알고리즘을 구현하는 방법

- 재귀적인 구조를 찾았다면, 찾은 구조에 알맞는 DP Table 완성하면 됨
- DP Table 을 완성하는 방법 크게 두 가지

### 1. Bottom-Up 방식

- 작은 부분부터 완성하는 방식으로 보통 반복문을 이용하여 DP Table 을 완성
- DP Table 전체를 완성해야 하는 경우 사용하면 좋다

🔼 반복문을 이용하여 갱신하므로 초보자 입장에서 코드를 이해하기 쉽다.

🔽 DP Table의 값을 갱신하는 과정에서 접근하는 순서에 유의할 필요가 있다(즉, 아직 갱신되지 않은 부분의 값을 사용하면 안된다)

**백준 11048 구현**

```python
r, c = map(int, input().split())

# n+1 x m+1	행렬 만들기
arr = [[0] + list(map(int, input().split())) for _ in range(r)] # 0행 추가
arr = [[0] * (c + 1)] + arr # 0열 추가

f = [[0 for _ in range(c+1)] for _ in range(r+1)]

# 초기값 설정 : 0, 바텀업 방식은 이미 위에서 0으로 초기화했으므로 안해줘도 됨
# for j in range(0, c + 1):
#     f[0][j] = 0

# for i in range(0, r + 1):
#     f[i][0] = 0
    
for i in range(1, r+1):
    for j in range(1, c+1):
        f[i][j] = max(f[i-1][j], f[i][j-1], f[i-1][j-1]) + arr[i][j]
    
print(f[r][c])
```

### 2. Top-Down 방식

- 큰 부분(구하고자 하는 값)을 기준으로 DP Table 의 필요한 부분만 구하는 방식으로, 재귀함수를 이용한다.
- DP Table의 일부만 완성해도 되는 경우 사용하면 좋다

🔼 DP Table의 값은 재귀적인 과정을 거치며 필요한 부분만 접근하기 때문에 순서를 따로 고려할 필요는 없다.

🔽 재귀 함수 구현이 익숙하지 않다면, 코딩할 때 어려울 수 있다

**백준 11048 구현**

```python
import sys
sys.setrecursionlimit(1000000)

def func(i, j):
	global arr, f

	if f[i][j] != -1:
		return f[i][j]
	
	f[i][j] = max(func(i-1, j), func(i, j-1), func(i-1, j-1)) + arr[i][j]
	return f[i][j]

r, c = map(int, input().split())

# n+1 x m+1	행렬 만들기
arr = [[0] + list(map(int, input().split())) for _ in range(r)] # 0행 추가
arr = [[0] * (c + 1)] + arr # 0열 추가

f = [[-1 for _ in range(c+1)] for _ in range(r+1)]

# 초기값 설정 : 0
for j in range(0, c + 1):
    f[0][j] = 0

for i in range(0, r + 1):
    f[i][0] = 0
    
print(func(r, c))
```

## DP 문제를 잘 풀려면 어떻게 할까?

- DP 가 어려운 이유
    - DP 로 문제를 해결하려면 문제의 재귀적인 구조(관계식)를 찾아야 하기 때문
    - 즉, 적절한 형태의 DP Table 구조를 설계하는 과정이 DP 를 처음 배울 때는 쉽지 않음
    - DP 문제의 난이도를 결정하는 것은 구현 난이도보다는 DP Table 설계 난이도이다.

### DP 문제 푸는 실력 키우기

- 문제를 DP 로 해결하는 능력 키워야 함
- 따라서, 다음과 같은 과정을 여러번 연습해야 함
    1. **문제에서 적절한 DP Table 구조를 설계**
    
    <aside>
    ✅
    
    코테에서 나오는 문제 수준은 `실버5 ~ 골드3`이며, 보통 `실버5 ~ 골드3` 정도의 DP 문제는 DP Table의 형태가 문제에서 주어진 배열과 비슷한 형식
    
    </aside>
    
    1. **DP 식을 정의하고 타당한지 판단**
    2. **DP 식의 초기값을 구할 수 있는지 판단**
- DP는 최적해를 구하는 알고리즘으로 다음과 같은 경우에 많이 사용된다.
    - ~한 `경우의 수`를 구하시오
    - ~의 `최소값`을 구하시오
    - ~의 `최대값`을 구하시오

---

[출처 : 인프런, 세계 대회 진출자가 알려주는 코딩테스트 A to Z](https://www.inflearn.com/course/%EC%84%B8%EA%B3%84%EB%8C%80%ED%9A%8C-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%8C%8C%EC%9D%B4%EC%8D%AC)