---
title:  "[니어니어 프로젝트] S3 연동"
published : true
categories: niornear_project
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# S3 연동

[[AWS] 이미지 저장을 위한 S3 버킷 생성 및 SpringBoot(Gradle) 에 연동하기](https://velog.io/@yes_jihyeon/AWS-이미지-저장을-위한-S3-버킷-생성하기-SpringBootGradle)

# S3(Simple Storage Service) 개념

- 온라인 오브젝트(객체) 스토리지 서비스
- 구글 드라이브 처럼 파일 저장 서비스이며, 데이터를 온라인으로 오브젝트 형태로 저장하는 서비스
- 온라인이 붙는 이유 → 데이터 조작에 HTTP/HTTPS 를 통한 API 가 사용되기 때문
- 저장하는 데이터 양에 대한 비용도 저렴, 저장할 수 있는 데이터 양이 무한에 가까움
- 또한, ‘elastic’한 성질때문에 별도의 스토리지 확장, 축소에 신경쓰지 않아도 됨
- FTP 서버처럼 단순한 파일 저장 영역으로 사용할 수도 있고, 다양한 AWS 서비스의 사용 로그 저장, 정적 웹 사이트 호스팅, EBS 스냅샷의 저장 영역 기능 등을 가지고 있음
- S3 는 지역별 서비스로서 지역별 재난 상황에 대비하여 자동으로 반복 저장을 한다.

## S3 객체 스토리지 특징

- 객체 스토리지란 객체로 된 파일을 다루는 저장소
- 이와 반대되는 것이 EBS(Block storage Service) 가 있다.(EBS 는 일종의 SSD 나 하드라고 보면 됨)
- S3 객체 스토리지에서는 파일을 설치하는 행위는 불가능하다. 이미지, 동영상 파일 등만을 저장할 수 있다.
- 즉, 파일 업로드, 삭제, 업데이트만 가능.

## S3 사용하는 이유

- S3 는 저장 용량이 무한대, 파일 저장에 최적화되어 있음. 용량을 추가하거나 성능을 높이는 작업이 필요없다.
- 비용은 EC2 와 EBS 로 구축하는 것보다 훨씬 저렴
- S3 자체가 수천 대 이상의 매우 성능이 좋은 웹 서버로 구성되어 있어서 EC2 와 EBS 로 구축했을 때 처럼 Auto Scaling 이나 Load Balancing 에 신경쓰지 않아도 됨
- 웹하드 서비스와 비슷하지만, 별도의 클라이언트 설치 등을 하지 않고 HTTP 프로토콜로 파일 업로드/다운로드 처리가 가능
- S3 자체로 정적 웹서비스 가능 (html 파일을 스토리지에 저장, html 파일에 접근하면 그게 홈페이지)
- 동적 웹페이지와 정적 웹페이지가 섞여있을 때 동적 웹페이지만 EC2 에서 서비스하고 정적 웹페이지는 S3 를 이용하면 성능도 높이고 비용도 절감 가능

## S3 사용 예

- 클라우드 저장소 (개인 파일 보관, 구글 드라이브처럼 사용 가능)
- 서비스의 대용량 파일 저장소 - 이미지, 동영상, 빅데이터 (ex : 넷플릭스)
- 서비스 로그 저장 및 분석
- AWS 아데나를 이용한 빅데이터 업로드 및 분석
- 서비스 사용자의 데이터 업로드 서버 (이미지 서버, 동영상 서버)
- 중요한 파일은 EC2 의 SSD (EBS: Elastic Block Storage) 에 저장하지 말고 S3 에 저장
- glacier 와의 연동으로 비용 절감 및 규정 준수 가능
    - 빙하라는 뜻으로 자주 쓰지 않는 데이터를 S3에서 자동으로 변환

## S3 버킷 / 객체 개념

- 객체(Object)는 데이터와 메타데이터를 구성하고 있는 저장 단위
- 버킷(Bucket)은 이러한 객체를 저장하고 관리하는 역할
- 버킷은 그냥 디렉토리/폴더 개념으로 키는 파일명으로 이해

만약 User 라는 이름의 버킷에 profile.png 객체 파일을 저장하면 [https://User.s3.amazonaws.com/profile.png](https://User.s3.amazonaws.com/profile.png) 라는 URL 이 생성됨

**S3 구성**

- 버킷(Bucket)이라는 컨테이너를 놓을 리전을 선택
- 해당 컨테이너 내부에 객체(Object) 라는 형태로 데이터를 저장

**S3 제한**

- 한 계정 당 Bucket 은 최대 100개까지 사용 가능, 버킷 단위로 접근 제한 설정 가능
- 단, Bucket 의 소유권은 이전할 수 없기 때문에 주의해야 함
- 객체는 하나 당 1Byte ~ 5TB 까지 저장이 가능하며, 저장할 수 있는 객체의 수는 제한이 없다.
- 각 객체는 메타 데이터를 지니는데, 최종 수정일 / 파일 타입 등의 데이터로 구성되어 있다.(네임-벨류 쌍)
- S3 내에서 버킷, 키, 버전 ID 를 통해 특정 객체 파악 가능

### S3 리전(Region) 구성

- S3 가 생성한 버킷을 저장할 위치를 지정한다.
- 리전 간 객체 공유는 불가능
- 버킷 위치(리전)을 어디에 지정하냐에 따라 지연 시간, 비용 등이 결정됨

### S3 버킷(bucket) 구성

- Amazon S3 에서 생성되는 최상위 디렉토리, Amazon S3 에 저장된 객체의 컨테이너
- S3 상의 모든 객체는 버킷에 포함
- 버킷의 이름은 S3 에서 유일해야 함
    - 전세계에 어디에도 중복된 이름이 존재할 수 없음
- 버킷 주소는 [https://bucketname.s3.Region.amazonaws.com](https://bucketname.s3.Region.amazonaws.com) 형태로 이루어짐
- 버킷 생성 시 default 로 private 상태
- 버킷 소유권 이전 불가
- 버킷 안에 다른 버킷 둘 수 X

### S3 객체 구성

- Key : 파일의 이름
    - 버킷 내 객체의 고유 식별자. 버킷 내 모든 객체는 정확히 하나의 키를 갖는다.
        - 즉, S3 에 올라갈 파일 이름을 지정할 때는 UUID 등 겹치지 않는 식별자를 사용해야 한다.
    - 버킷, 키 및 버전 ID 의 조합은 각 객체를 고유하게 식별한다.
- Value
    - S3 은 Key-Value 형태로 저장되지만, Key 의 접두어 및 슬래시를 이용하여 폴더 개념 같이 사용 가능
- Version Id
    - Version ID 는 S3 의 고유 특징 중 하나
    - 같은 파일이지만 다른 버전으로 올릴 수 있게 돕는 인식표
    - 만약 이전 버전으로 돌아가고 싶다면, Version ID 를 통해 쉽게복원 가능
- MetaData
    - 최종 수정일, 파일 타입, 파일 소유자, 사이즈 … 등
- ACL : 파일의 권한을 담은 데이터 (접근이나 수정)
- Torrents : 토렌트 공유를 위한 데이터
- CORS : 한 버킷의 파일을 지역을 무시하고 다른 버킷에서 접근 가능하게 해주는 기능

### S3 객체(Object) 특징

- 객체 하나의 크기는 1Byte ~ 5TB
- 저장 가능한 객체 갯수 무제한
- 객체마다 각각의 접근 권한 설정 가능
- 객체 metadata 는 객체가 업로드 된 후에는 수정될 수 없고, 복사해서 수정해야 한다.
- 객체의 metadata 는 response header 에 반환된다.
- 객체를 그룹화하는 디렉터리를 생성할 수 있다. 따라서 폴더, 파일처럼 디렉터리를 계층화해서 객체 저장 가능

## S3 버저닝 (Versioning)

- 자동화된 백업 관리 기법인 버전 관리 및 생애주기 관리 기법을 제공
- 버저닝은 특정 객체에 여러 버전을 유지하는 수단
    - 파일에 버전 아이디를 붙임 → 버전 관리를 사용하여 S3 버킷에 저장된 모든 객체의 버전을 보존, 검색 및 복원할 수 있다.
    - 또한 의도하지 않은 사용자 작업과 응용 프로그램 오류 모두 쉽게 복구할 수 있다
- 그러나 비용을 조심해야 한다.
- 버킷을 만들 때 기본적으로 비활성화라, 직접 활성화해야 한다.
    - 단, 버킷에서 버전을 사용하도록 설정한 후에는 비활성화 상태로 돌아갈 수 없다.
    - 대신 버전 관리 일시 중지 설정은 가능

### 객체 버전 ID 수정 / 삭제 / 조회 동작

- 버전 관리 사용 설정 → 저장되는 객체에 대한 고유한 버전 ID 자동 생성
  
    예) photo.gif(버전ID : 111111), photo.gif(버전ID : 121212)와 같이 한 버킷에 키 값은 동일하지만 버전 ID 가 다른 두 객체 보유 가능
    
- 파일 수정 시의 동작
    - 버전 관리 사용 시, 버킷에 객체를 PUT(REST API 의 수정 동작 명령)할 때 파일 덮어쓰지 X
    - 원래 객체는 버킷에 남아있으면서 S3 가 새 버전ID 를 만들어서 버킷에 추가해 위로 올림 (맨 위에 올려진게 최신 데이터로 인식) ⇒ stack 느낌
- 파일 삭제 시의 동작
    - 버킷에 삭제 마커(Delete Marker) 를 삽입
    - 파일을 실제 삭제한 것이 아니라, 삭제 마커를 최상단에 올림으로 마치 파일이 삭제된 것처럼 효과를 주는 것
    - 만약에 버전 관리되는 객체를 영구적으로 삭제하려면 버전 ID 자체를 삭제해야 함
    - 최신 버전이 삭제 마커일 때 간단한 GET Object 요청ㅇ르 수행하면 Not Found 오류가 반환됨
    - 그러나, 버전 ID 를 지정하여 특정 객체에 대해 GET 을 수행하면 그 객체를 반환받을 수 있음

## S3 보안 / 권한 (접근 제어)

- S3의 버킷 기본 정책은 private
- 만약 외부에서 접속해 S3 의 버킷을 제어할 필요가 있다면?
- 버킷을 통째로 public 으로 개방하는 것 X. S3 권한 제어를 통해 접근 제어 설정

S3 권한 설정 대표적인 4가지

1. 사용자 생성, 사용자의 버킷 권한 액세스 관리 ⇒ IAM
2. 권한 있는 사용자에 대해 간단한 개별 객체를 액세스 가능하게 관리 ⇒ 액세스 제어 목록(ACL)
3. 단일 S3 버킷 내 모든 객체에 대한 권한을 세부적으로 구성 ⇒ 버킷 정책(bucket policy)
4. 임시 URL 을 사용하여 다른 사용자에게 기간 제한(임시 권한) 액세스를 부여 ⇒ 쿼리 문자열 인증(pre-signed URL)

위의 액세스 관리 기능을 조합하여 사용 → 다른 사용자에게 액세스 권한 부여 가능

![image01]({{site.url}}/assets/images/2024-08-09-niornear_project(3)/image01.png)

### Public Access

- 퍼블릭 액세스 권한 → 모두에게 액세스 권한을 오픈 or 임의의 사용자에게 접근 권한 제한할 것인지 설정하는 것
  
    ![image02]({{site.url}}/assets/images/2024-08-09-niornear_project(3)/image02.png)
    
    - 옵션이 4가지 존재 → 특수한 경우 퍼블릭 액세스 허용되는 경우 각각 설정 가능
    - 최상위 모든 퍼블릭 액세스 차단을 설정 → 어떤 경우이든 모든 접속 차단

❗ 실무에서 사용할 경우 모든 액세스 차단 혹은 ACL 을 이용하여 액세스 차단해주는 것이 보안을 위해 좋음

### ACL(Access Control List)

- ACL 은 **버킷이나 객체에 대해 요청자의 권한 허용 범위를 어디까지 설정할 것**인가 간단하게 설정 가능
    - 요청자는 일반 퍼블릭한 사용자, 계정의 owner/resource group, 특정 사용자가 될 수 있음
    - 버킷 주인과 오브젝트 주인이 다를 경우 권한 설정, log 저장용 버킷에 대한 권한 설정 등을 할 수 있음
- 버킷과 그 속에 포함된 객체는 ACL 과 연동
    - ACL 로 S3 버킷이나 객체의 접근을 제어하는 게 가능
- ACL 은 IAM 이나 버킷 정책에 비해 더 넓은 범위에서 제어할 수 있지만, 단지 접근 승인한 곳, 정급 승인을 받은 곳으로만 나타낼 수 있음

![image03]({{site.url}}/assets/images/2024-08-09-niornear_project(3)/image03.png)

### 버킷 정책(Bucket Policy)

- 버킷 정책 → **버킷을 사용할 권한을 가진 여러 명의 사용자 별로 각각의 행위에 대한 권한 범위**를 설정 가능
  
    예) 누군가는 읽기만 가능, 누군가는 읽기, 쓰기 모두 가능한 상태
    
- 버킷에 대한 전반적인 권한 설정은 Bucket Policy 를 통해 설정
    - 단, 버킷 안 파일 하나하나의 권한 설정은 불가
- 버킷 정책은 json 형식으로 이루어짐

```jsx
{
    "Version": "2012-10-17", // Bucket Policy의 문법이 언제 날짜 기준으로 확정된 문법을 사용하는지 → 2008-10-17 버전 후 2012-10-17 버전이 있는데, 그 뒤로는 업데이트가 안됐음
    "Id": "S3PolicyId1", // Bucket Policy의 고유 아이디, 자동으로 부여되는 경우가 많음
    "Statement": [
        {
            "Sid": "IPAllow", // 각 Statement의 고유 아이디. 무슨 역할을 하는 policy인가
            "Effect": "Allow", // 버킷에 대한 명령을 허락(allow)하거나 거부(deny). 특정 사용자에 대해 명령을 제한하거나, 허용하는 식으로 사용
            "Principal": {"AWS": "arn:aws:iam::spark323:user/spark"}, // Bucket Policy의 적용대상 (spark323 아이디의 유저에 대해서)
            "Action": [ // Bucket Policy에서 허용한 Action
                "s3:GetObject", // 객체 가져오는 행동
                "s3:GetBucketLocation", // 버켓 위치를 확인하는 행동
                "s3:ListBucket", // 버켓 리스트를 확인하는 행동
            ],
            "Resource": "arn:aws:s3:::bucketname/*", // 대상이 대는 Bucket에 대한 명세
            "Condition": { // 어떤 조건 하에
                "NotIpAddress": { // 이 IP비허용
                    "aws:SourceIp": "1.1.1.1/32"
                },
                "IpAddress": { // 이 IP허용
                    "aws:SourceIp": [
                        "192.168.1.1",
                        "192.168.1.2/32",
                    ]
                }
            }
        }
    ]
}
```

**해석**

계정 spark323 아이디인 유저에 대해서 Resource(해당버킷)에 대해 Action(객체를 가져오거나 버킷 위치를 확인하거나)을 Effect(허용) Condition(아이피 192.168.1.1, 192.168.1.2/32 인 하에) 한다는 말

<aside>
💡 TIP!
버킷 정책의 IAM 사용자 단위 제어 → IAM 사용자 명칭과 일치하는 버킷만 사용할 수 있게 제한
따라서 IAM 사용자 제어 시 IAM 정책 사용하는 것이 좋음
</aside>

### ACL 과 Bucket Policy 차이

- ACL 이나 버킷 정책 둘다 버킷에 대한 액세스를 제한하거나 허용하는 권한 설저
- 버킷정책은 버킷에 대해서만 권한을 설정할 수 있지만, ACL 은 버킷 뿐만 아니라 개별 객체에도 가능
- 버킷정책은 JSON 을 통해 세분화된 권한을 설정 가능, ACL 은 버킷 정책만큼 세분화된 액세스 모드 제공 X

## S3 요금 정책

- S3 Glacier 같은 장기 보관용 등급의 경우 storage 저장 비용은 저렴, 데이터를 꺼낼 때 요금이 굉장히 셈
- 동일한 리전의 EC2 와는 데이터 전송 요금이 발생하지 않으므로 S3 와 EC2 리전은 동일하게 설계

![image04]({{site.url}}/assets/images/2024-08-09-niornear_project(3)/image04.png)

# S3 접근 권한

[[AWS] 📚 S3 개념 & 버킷 · 권한 설정 방법](https://inpa.tistory.com/entry/AWS-📚-S3-버킷-생성-사용법-실전-구축)