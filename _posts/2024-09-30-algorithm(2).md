---
layout: single
title:  "[ALGORITHM TEST] 배열과 리스트 문제 풀이 2주차"
---

## 구간합 구하기 2(백준 11660)

### 문제 분석

> 나는 2차원 배열도 1차원 배열의 구간과 똑같은 줄 알고, 수직선 위에서의 구간합으로 생각하고 풀었다.



### 슈도코드(내 첫 풀이)

```java
N, M 입력 받기(BufferedReader)

int num = 0; // 더했던 가장 마지막 결과가 담기
long s_nums = long[N*N+1]; // 합 배열
int index = 1

// 합 배열
for(i : 1부터 N+1까지 돌기)
	BufferedReader 로 한 줄 다 받아오기
	StringTokenizer 로 토큰 받기

	for(j : 1부터 N+1까지 돌기)
		s_nums[index] = s_nums[index-1] + stringTokenizer.nextToken();
		index++;

// 결과 저장하기
long result[] = new long[M];
for(M 번 반복)
	BufferedReader 로 한 줄 다 받아오기
	StringTokenizer
	int x1 = Integer.parseInt(stringTokenizer.nextToken());
	int y1 = Integer.parseInt(stirngTokenizer.nextToken());
	int x2 = Integer.parseInt(stringTokenizer.nextToken());
	int y2 = Integer.parseInt(stringTokenizer.nextToken());
	
	result[m] = s_nums[(x2-1)*N+y2] - s_nums[(x1-1)*N+y1];
}

// 결과 출력하기
for(M 번 반복)
	sout(result[m]);
```

### 구현(내 첫 풀이)

```java
package list;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());

        int n = Integer.parseInt(stringTokenizer.nextToken());
        int m = Integer.parseInt(stringTokenizer.nextToken());
        
        // 합 배열
        long s_nums[] = new long[n*n+1];
        int index = 1;
        for(int i = 1; i<n+1; i++) {
            stringTokenizer = new StringTokenizer(bufferedReader.readLine());
            for(int j = 1; j<n+1; j++) {
                s_nums[index] = s_nums[index-1] + Integer.parseInt(stringTokenizer.nextToken());
                index++;
            }
        }

        // 결과 저장하기
        long result[] = new long[m];
        for(int i = 0; i<m; i++) {
            stringTokenizer = new StringTokenizer(bufferedReader.readLine());

            int x1 = Integer.parseInt(stringTokenizer.nextToken());
            int y1 = Integer.parseInt(stringTokenizer.nextToken());
            int x2 = Integer.parseInt(stringTokenizer.nextToken());
            int y2 = Integer.parseInt(stringTokenizer.nextToken());

            boolean special = (x1==x2 && y1==y2) || (x1==1 && y1==1 && x2==n && y2==n);
            if(special) {
                result[i] = s_nums[(x2-1)*n+y2] - s_nums[(x1-1)*n+y1-1];
                continue;
            }

            result[i] = s_nums[(x2-1)*n+y2] - s_nums[(x1-1)*n+y1];
        }

        for(long num: result) {
            System.out.println(num);
        }
    }
}

```

## 구간합 구하기 2(백준 11660) : 책으로 합 배열 구하는 법 보고 풀이한 것

### 1. 문제 분석

**D\[X\]\[Y\] = 원본 배열의 (0, 0)부터 (X, Y) 까지의 사각형 영역 안에 있는 수의 합**

> 챗 지피티한테 물어본 결과, 2차원 배열의 구간 합을 구할 때 사각형 영역을 구하는 것은 정의임. 
>
> **1차원 구간: 수직선이나 수평선 상에서 정해진 범위 내의 값을 합산.**
>
> **2차원 구간: 평면 위에서 정의된 직사각형 안의 값을 합산.**

즉, 내가 위에서 문제 분석할 때 (2, 2) - (3, 4) 구간합에서 6을 더하지 않은 것을 이상하게 생각하고 사각형이라는 특징을 발견했어야 하는 것!

앞으로는 그림을 꼭꼭 그려보자! 모르겠으면 무조건 그림 그리는 것이 규칙성을 발견하기 좋을듯 하다.

> ✅ tip! 만약, N 과 같은 데이터 전체 개수보다 M 과 같이 실행 횟수, 즉 정답을 구하는 등의 실행 횟수가 많으면 이것은 미리 구해놓은 데이터를 출력하는 식으로 풀어야 하는 문제일 가능성이 높다.
>
> 실행 횟수마다 탐색하거나 연산하여 찾으려고 하면, 시간 제한 안에 못 푼다.

### 2. 손으로 풀어보기 : 여기가 제일 중요

- **🔥 여기서 그림 그려보고, 시각화하면서 규칙을 찾는 것이 문제 풀이의 핵심!**

![PNG-ECBA150AF5AF-1]({{site.url}}/images/2024-09-30-algorithm(2)/PNG-ECBA150AF5AF-1.png)

![PNG-50C440DC08CC-2]({{site.url}}/images/2024-09-30-algorithm(2)/PNG-50C440DC08CC-2.png)

### 3. 슈도 코드

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer

// n, m 받기
BufferedReader = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer = new StringTokenizer(bufferedReader.readLine());

int n = stringTokenizer.nextToken();
int m = stringTokenizer.nextToken();

// 기본, 합 배열 선언
int arr[][] = new int[n+1][n+1];
long s_arr[][] = new long[n+1][n+1];

// 기본 배열 받기(for 문 N*N 번)
for(int i = 1; i < N+1; i++) {
		// 여기서 한 줄 입력받기
		for(int j = 1; j < N+1; j++) {
				arr[i][j] = stringTokenizer.nextToken();
		}
}

// 합 배열 구하기(for 문 N*N 번)
for(int i = 1; i<N+1; i++) {
		for(int j = 1; j < N+1; j++) {
				s_arr[i][j] = s_arr[i-1][j] + s_arr[i][j-1] - s_arr[i-1][j-1] + arr[i][j];
		}
}

// 합 배열로 구간합 구하기(for 문 M 번)
long result[] = new long[m];
for(int i = 0; i<m; i++) {
		stringTokenizer = 입력받기
		
		int x1 = stringTokenizer.nextToken();
		int y1 = stringTokenizer.nextToken();
		int x2 = stringTokenizer.nextToken();
		int y2 = stringTokenizer.nextToken();
		
		result[i] = s_arr[x2][y2] - s_arr[x2][y1-1] - s_arr[x1-1][y2] + s_arr[x1-1][y1-1];
}

// 결과 출력
```

### 4. 구현

```java
package list;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());

        // n, m 받기
        int n = Integer.parseInt(stringTokenizer.nextToken());
        int m = Integer.parseInt(stringTokenizer.nextToken());
        
        // 기본 배열, 합 배열 선언
        int arr[][] = new int[n+1][n+1];
        long s_arr[][] = new long[n+1][n+1];

        // 기본 배열 받기
        for(int i = 1; i<arr.length; i++) {
            stringTokenizer = new StringTokenizer(bufferedReader.readLine());
            for(int j = 1; j<arr.length; j++) {
                arr[i][j] = Integer.parseInt(stringTokenizer.nextToken());
            }
        }

        // 합 배열
        for(int i = 1; i<s_arr.length; i++) {
            for(int j = 1; j<s_arr.length; j++) {
                s_arr[i][j] = s_arr[i-1][j] + s_arr[i][j-1] - s_arr[i-1][j-1] + arr[i][j];
            }
        }

        long[] result = new long[m];
        // 합 배열로 구간합 구하기
        for(int i = 0; i<m; i++) {
            stringTokenizer = new StringTokenizer(bufferedReader.readLine());
            
            int x1 = Integer.parseInt(stringTokenizer.nextToken());
            int y1 = Integer.parseInt(stringTokenizer.nextToken());
            int x2 = Integer.parseInt(stringTokenizer.nextToken());
            int y2 = Integer.parseInt(stringTokenizer.nextToken());

            result[i] = s_arr[x2][y2] - s_arr[x2][y1-1] - s_arr[x1-1][y2] + s_arr[x1-1][y1-1];

        }

        for(long num: result) {
            System.out.println(num);
        }
    }
}
```
## 나머지 합 구하기(백준 10986)

### 1. 문제 분석

N개의 수 $A_1, A_2, ... A_N$

연속된 부분의 합이 M 으로 나누어 떨어지는 구간의 개수를 구하는 문제

[입력] N = 구간의 개수, M 연속된 부분의 합을 나누는 수

[제한] $1 <= N <= 106, 2 <= M <= 103, 0 <= A_i <= 109$

- 대략적으로 10^2 개이므로, N^2 정도로 풀어도 됨

### 2. 손으로 풀기

### 3. 슈도 코드

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;

// n, m 받기
BuffertedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(bufferedReader.readLine());
int n = st.nextToken();
int m = st.nextToken();

// 합 배열 선언하기
long s_arr[] = new long[n+1];
// m 으로 나누어지는 구간합 쌍 카운트하는 변수 선언
int count = 0;

// 합 배열 만들기
st = new StringTokenizer(bf.readLine());
for(int i = 1; i<s_arr.length; i++) {
  s_arr[i] = s_arr[i-1] + st.nextToken();
}

// m 으로 나누어지는 구간합 구하기
for(int i = 1; i < s_arr.length; i++) {
  for(int j = i; j < s_arr.length; j++) {
    int num = s_arr[j] - s_arr[i-1];
    if(num % m == 0) {
      count++;
    }
  }
}

// count 출력
sout(count)
```

### 4. 구현

```java
package list;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(bufferedReader.readLine());

        // n, m 받기
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        // 합 배열 선언
        long s_arr[] = new long[n+1];
        int count = 0;

        // 합 배열 만들기
        st = new StringTokenizer(bufferedReader.readLine());
        for(int i = 1; i<s_arr.length; i++) {
            s_arr[i] = s_arr[i-1] + Integer.parseInt(st.nextToken());
        }

        // m 으로 나누어지는 구간합 구하기
        for(int i = 1; i<s_arr.length; i++) {
            for(int j = i; j<s_arr.length; j++) {
                long num = s_arr[j] - s_arr[i-1];
                if(num % m == 0) {
                    count++;
                }
            }
        }

        System.out.println(count);
        
    }
    
}

```

## 나머지 합 구하기(백준 10986) : 

### 1. 문제 분석하기

[핵심 아이디어]

**(A+B) % C = (A%C) + (B%C)**

- 모듈러 연산의 특수성

  - 나머지를 구하는 연산이므로, 모듈러 연산을 적용한 값은 항상 특정 범위 내에 있어야 함
  - 예) C 로 나눈 나머지는 항상 0 이상 C - 1 이하의 값

- 모듈러 연산의 성질 중 하나

  - 덧셈에 대한 분배법칙과 유사해보이지만 다름

    (A+B) % C = ((A%C)+(B%C)) % C

- 구간 합 배열을 이용한 식 S[i] - S[j]  는 원본 배열의 j+1 부터 i 까지의 구간 합

- S[i] % M 의 값과 S[j] % M 의 값이 같다면, (S[i] - S[j]) % M 은 0

  - 즉 구간 합 배열의 원소를 M 으로 나눈 나머지로 업데이트 하고 S[i] 와 S[j] 가 같은 (i, j) 쌍을 찾으면 원본 배열에서 j+1 부터 i 까지의 구간 합이 M 으로 나누어 떨어진다는 것을 알 수 있음

  ![IMG_DA2FB5A682C0-1]({{site.url}}/images/2024-09-30-algorithm(2)/IMG_DA2FB5A682C0-1.jpeg)

### 2. 손으로 풀어보기

![PNG-3FE2FF69B509-1]({{site.url}}/images/2024-09-30-algorithm(2)/PNG-3FE2FF69B509-1.png)

### 3. 슈도코드

```java
// n, m 받기

// 나머지 연산 수행한 합 배열 생성
for(int i = 1; i<n+1; i++) {
		s_arr[i] = (s_arr[i-1] + Integer.parseInt(st.next)) % m
}

int count = new int[m]; // 같은 나머지 count 하기
// 0인 개수 세기, 변경된 합 배열에서 원소 값이 같은 인덱스 개수 세기
for(int i = 1; i<s_arr.length; i++) {
	count[s_arr[i]]++;
}

// count 배열로 공통된 인덱스 수로 경우의 수 구하기
int result = count[0];
for(int i = 0; i<m; i++) { // 0 도 공통된 수로 포함해서 계산해야 함. 구간 조합으로도 0이 나올 수 있으므로
  // count[i] 개 중에 2개를 뽑는 경우의 수 계산 공식 count[i] * (count[i] - 1) / 2
	int result += combination(count[i], 2); 
}

sout(result);
```

- n 개 중에 2개 뽑는 조합 공식(특수)

  **n * (n-1) / 2**

### 4. 구현

```java
package list;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(bufferedReader.readLine());

        // n, m 받기
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        // 합 배열 선언
        long s_arr[] = new long[n+1];

        // 나머지 연산 수행한 합 배열 생성
        st = new StringTokenizer(bufferedReader.readLine());
        for(int i = 1; i<s_arr.length; i++) {
            s_arr[i] = (s_arr[i-1] + Integer.parseInt(st.nextToken())) % m;
        }

        long count[] = new long[m];
        // 나머지를 반영한 합 배열의 같은 값들 개수 세기
        for(int i = 1; i<s_arr.length; i++) {
            count[(int)s_arr[i]]++;
        }


        // count 배열로 공통된 인덱스 수로 경우의 수 구하기
        long result = count[0];
        for(int i = 0; i<m; i++) {
            // count[i] 개 중에 2개를 뽑는 경우의 수 계산 공식 count[i] * (count[i] - 1) / 2
            result += count[i] * (count[i] - 1) / 2;
        }

        System.out.println(result);
        
    }
}
```

- s_arr, count, result 를 long 으로 바꿔줌

  - int 로 설정하니 틀렸다고 나옴, int 가 담을 수 있는 범위를 나간 거 같아서 확인해보니

  [입력]

  첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 10^6, 2 ≤ M ≤ 10^3)

  둘째 줄에 N개의 수 A1, A2, ..., AN이 주어진다. (0 ≤ A_i ≤ 10^9)

  - 이렇게 되어 있었음(책의 오탈자)

  그래서 처음 n^2 풀이도 시간 초과가 나왔던 것..

  - 즉, A_i 를 받고 이걸 연산할 때 약 10^9 까지 가능한 int 로 받고 처리하니 문제가 생길 수 있었던 것

- 그리고 조합 구현하려고, 막 알아보다가 결국 답을 보니 n 개 중에 2개 뽑는 조합 공식이 따로 있었다... 수학 열심히 하자..

**✅  앞으로 주의해야 할 것 : 합 관련하여 값이 큰 경우에는 long 을 사용할 것**

---

출처 : 김종관, 『Do it! 알고리즘 코딩 테스트 - 자바 편』, 이지퍼블리싱(2022).