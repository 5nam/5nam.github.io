---
title:  "[DATA STRUCTURE] 자료구조 및 알고리즘 개요"
categories: data_structure
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

## 자료구조

- 데이터 보관 방법과 데이터에 관한 연산의 총체

### 자료구조의 분류

**단순 자료구조(Primitive Data Structure)**

- int, long, double ...

**복합 자료구조(Non-Privitive Data Structure)**

- 선형 자료구조(Linear Data Sturucture)

  데이터 요소를 순차적으로 연결하는 자료구조, 구현하기 쉽고 사용하기도 쉬움

  - 배열
  - 링크드 리스트
  - 스택
  - 큐
  - 힙

- 비선형 자료구조(Non-Linear Data Structure)

  데이터 요소를 비순차적으로 연결

  - 트리
  - 그래프

### ADT(Abstract Data Types)

- 추상 데이터 형식, 자료구조의 동작 방법을 표현하는 데이터 형식
- 자료구조가 갖춰야 할 일련의 연산
- ADT 가 청사진을 제시하면 자료구조는 이를 구현함
- ADT 는 개념을 제시하고, 자료구조는 구현을 포함함

| ADT    | 자료구조                                               |
| ------ | ------------------------------------------------------ |
| 리스트 | 링크드 리스트<br />더블 링크드 리스트<br />환형 리스트 |
| 스택   | 배열 기반 스택<br />링크드 리스트 기반 스택            |
| 큐     | 환형 큐<br />링크드 큐                                 |
| 트리   | 이진 트리<br />LCRS 트리<br />레드 블랙 트리           |
| 그래프 | 방향성 그래프<br />무방향성 그래프                     |
| 힙     | 배열 기반 힙<br />링크드 리스트 기반 힙                |

### 자료구조를 공부해야 하는 이유

1. 자료구조 내부를 이해하면 라이브러리에서 상황마다 알맞은 자료구조를 선택할 수 있다.

   - 동일한 ADT 를 사용하더라도 자료구조에 따라 애플리케이션 성능이 달라질 수 있음

     예) 네트워크 애플리케이션의 입출력 버퍼에는 링크드 큐보다 환형 큐 사용하는 것이 속도 면에서 유리, 메모리의 효율이 더 중요한 애플리케이션은 링크드 큐가 환형 큐보다 나은 선택

2. 자료구는 알고리즘이 데이터를 효율적으로 사용할 수 있게 도와주는 핵심 부품 역할

   - 자료구조를 모르면 알고리즘 공부에 어려움이 따름

## C 언어로 메모리를 다루는 방법

### 포인터 복습

- `데이터 형식* 포인터;`

  ```c
  int* ptr = 0xFF000000; // 포인터에 주소값 할당 가능
  int* ptr = &a; // 주소 연산자 & 로 다른 변수의 주소를 할당 가능
  ```

- C 언어에서는 포인터에 증감 연산자 사용 가능

  예) int 형식 32비트(4바이트)인 시스템에서 int 인 포인터에 ++ 연산자 적용하면 주소값이 32비트 증가, -- 연산자 적용하면 32비트 감소

  ````C
  int* ptr = 0x1004 // 주소값 직접 할당
  printf("%X\n", ptr); // 1004 (초기값)
  printf("%X\n", --ptr); // 1004 (4 감소)
  printf("%X\n", ++ptr); // 1004 (4 증가)
  ````

- C 언어에서 배열은 배열에 할당된 메모리의 시작 주소를 가짐

  - 배열이 메모리 주소를 담고 있으므로 포인터에 배열을 할당하면 포인터가 배열을 가리킬 수 있음

  ```c
  int arr[5] = {0, 1, 2, 3, 4};
  int* ptr = arr;
  
  printf("%s\n", ptr == arr ? "true" : "false");
  
  printf("%d\n", *ptr); // arr 의 첫 번째 요소 출력
  ```

  - ++ 연산자를 통해 arr 의 두 번째 요소 출력

  ```c
  ptr++;
  printf("%d\n", *ptr); // arr 두 번째 요소 출력
  ```

  - -- 연산자로 다시 arr 의 첫 번째 요소 출력

  ```c
  ptr--;
  printf("%d\n", *ptr); // arr 의 첫 번째 요소 출력
  ```

### 구조체 복습

- 다른 데이터 형식을 조합해서 만드는 사용자 정의 데이터 형식

```c
struct Point
{
		int x;
		int y;
}

struct Point MyPoint = {30, 40}; // x 는 30, y 는 40으로 초기화
printf("x: %d, y: %d\n", MyPoint.x, MyPoint.y); // 30, 40 출력
```

- Point 의 멤버 변수 x, y 에 접근할 때 접근 연산자 `.`  을 사용
  - 이 연산자의 이름은 멤버 접근 연산자
- 포인터를 통해 멤버에 접근할 때는 포인터 멤버 접근 연산자(`->`) 사용

```c
struct Point MyPoint = {30, 40};
struct Point* ptr = &MyPoint;

printf("x: %d, y: %d", ptr->x, ptr->y);
```

- Point 구조체 변수나 포인터를 선언할 때마다 struct 키워드를 언급해야 한다면 조금 불편할 것

  - `typedef` 키워드를 이용해서 구조체 이름만으로도 변수나 포인터를 선언할 수 있음

  ```c
  typedef struct tagPoint
  {
  		int x;
  		int y;
  } Point;
  
  // struct 키워드 없이 구조체의 별칭만으로 변수와 포인터 선언
  Point MyPoint = {30, 40};
  Point* ptr = &MyPoint;
  ```

### 메모리 레이아웃 복습

- 코드 컴파일 - 실행파일 생성 - 실행파일 실행 - 운영체제 실행파일 바탕으로 프로세스 생성 - 프로세스에 스택, 힙, 데이터, 텍스트 영역으로 이루어진 메모리 할당

  ![image-20240925130654227](../images/2024-09-25-datastructure(1)/image-20240925130654227.png)

  - 텍스트와 데이터 영역은 실행파일에서 읽어 들인 정보를 기록하는 공간

  - 텍스트 영역에는 CPU 가 실행할 코드가 적재

  - 데이터 영역(정적 메모리)에는 전역 변수나 정적 변수 저장

  - 힙(자유 저장소), 스택(자동 메모리) : 실행 중인 프로그램은 두 영역을 활발하게 사용

    ➡️ 더 자세히 살펴볼 것

### 스택에서 데이터를 다루는 방법

- 스택 ADT 는 선입후출 또는 후입선출 방식이다.
  - 출력은 입력의 역순으로 동작하는 것
- 스택 메모리 영역도 스택 ADT 와 같이 할당된 순서의 역순으로 메모리에서 변수를 제거한다는 규칙 따름

```
{ // 코드 블록 시작
		int a = 100;
		int b = 200;
		int c = 300;
}
```

1. 여는 괄호 { 가 시작되는 시점에는 스택에 아무것도 없음
2. int a = 10; 이 실행되면서 변수 a 가 스택에 쌓임
3. 그 다음 b 를 선언하면서 스택에는 a 위에 b 가 쌓이고 그 다음 c 가 쌓임
4. 그러다 블록을 닫는 괄호 } 를 만나면서 스택에 있는 데이터들이 cba 의 순서대로 제거됨

이 일련의 과정들이 스택이 왜 자동 메모리라고 불리는지 설명함

➡️ 프로그래머가 신경 쓰지 않아도 자동으로 메모리를 해제하기 때문

### 힙에서 데이터를 다루는 방법

- 힙은 자유 저장소라는 별명을 가짐.
- 자유 저장소는 자동 메모리와 달리 프로그래머가 직접 메모리를 관리하는 메모리 영역
- 프로그래머는 힙 위에 자유롭게 메모리를 할당할 수 있지만 메모리를 안전하게 해제하는 것도 프로그래머가 책임져야 함
- 메모리 할당할 때 `malloc()`, `calloc()`
- 메모리 해제할 때 `free()`

```c
typedef struct tagPoint
{
		int x;
		int y;
} Point;

Point *ptr = (Point*)malloc(sizeof(Point));
```

- 이 코드 실행하면 malloc() 이 Point 크기만큼 메모리 힙에 할당하고, 스택에 위치한 ptr 이 그 메모리 주소를 가리키게 됨

  ![image-20240925132434313](../images/2024-09-25-datastructure(1)/image-20240925132434313.png)

- ptr 은 자신이 태어난 코드 블록이 끝나는 곳에서 스택으로부터 제거되지만, malloc() 이 할당한 공간은 힙의 한 공간을 차지한 채 남아있음

  - 이만큼 애플리케이션이 사용할 수 있는 힙 공간이 줄어, 메모리 누수가 생기는 것

- 이런 메모리 누수를 방지하려면 할당한 메모리를 free() 로 해제해야 함

  ```c
  free(ptr);
  ```

  - 이 코드 실행 시, 힙에 ptr 이 가리키던 공간을 해제해서 메모리 누수 막을 수 있음

---

출처 : 박상현. (2020). 이것이 자료구조+알고리즘이다 with C 언어. 한빛미디어.