---
title:  "[ALGORITHM STUDY] 재귀함수 이해하기[문제풀이] : 10870"
published : true
categories: algorithm
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true
---

# 재귀함수 이해하기 [문제풀이] : 10870

- `강의에서 문제를 접근하는 과정`과 `자신이 문제를 접근했던 과정`을 비교하며 공부 (문제해결능력↑)
- `강의에서 나온 해설 코드`와 `자신이 구현한 코드`를 비교하며 공부 (구현력↑)

## 제약 조건

- 0 ≤ n ≤ 20

## 내 코드

```python
n = int(input())

def f(n):
    if n < 2:
        return n
    return f(n-1) + f(n-2)

print(f(n))
```

### 시간 복잡도

주요 연산 : 함수 호출 및 if 문이라고 생각하면

n = 5 일 때, 총 32번 호출. 즉, $2^n$

## 풀이 1) 반복문 + 메모이제이션 : O(n)

- O(n), n 이 최대 20 이기 때문에 통과
- 접근 방식
    1. 배열을 n+1 개 만큼 생성
    2. 0, 1번째 배열은 각각 0과 1로 초기화
    3. 그 후 2부터 n까지 for 문 돌면서 arr[i] = arr[i-1] + arr[i-2] 구하기
    4. 그리고 arr[n], n 번째 배열 출력

```python
n = int(input())

arr = [-1] * (n+2)
arr[0] = 0
arr[1] = 1

for i in range(2, n+1):
    arr[i] = arr[i-1] + arr[i-2]

print(arr[n])
```

- 왜 배열의 초기화를 -1 로 했는가?
    - 피보나치 수열에서 -1 은 나올 수 없는 수이기 때문에
    - 초기값을 설정할 때는 절대 나올 수 없는 값으로 설정하는 것이 좋음
- 왜 배열을 n+2 개 만들었는가?
    - n+1 은 n 이 0일 때 문제가 발생
    - 항상 arr[0], arr[1] 이렇게 먼저 초기화해주기 때문에 n 이 0 이면 오류가 발생할 수 있으므로 넉넉하게 n+2 개 만들어 주는 것

## 풀이 2) 재귀함수 : O(2^n)

- $O(2^n), 2^n, n$ 이 최대 20이기 때문에
    - $2^{20} = 2^{10} \times 2^{10} = 약\space1000 \times 1000 = 10^6$
    - 100만 이므로, 1억 번은 넘지 않으므로 통과
    
    ![image]({{site.url}}/assets/images/2025-01-01-algorithm(10)/image.png)
    
    - 위의 사진처럼 한번 호출하면 두 개씩 더 추가로 호출되고, 그 두 개는 각각 또 두 개를 호출
    - 그리고 두 개씩 호출되는 것은 색으로 표시한 것처럼 중복되는 값들임

**✅ 어떤 문제를 재귀함수를 통해서 구현할 수 있는지를 알 수 있는 방법은 문제에서 재귀적인 구조를 가지는지를 파악하면 됨**

- 접근 방식
    1. fibo(x) 는 피보나치의 x 번째 수를 반환하는 함수
    2. 재귀함수로 구현할 수 있는지 판단하기 위해서는 이전 값들과 현재 값이 어떤 관계가 있는지 살펴보면 됨
       
        **[Recursive Case]**
        
        - 즉, fibo(x) 를 구할 때 이전 값들을 사용할 수 있는가의 의미
        - 문제를 보면 fibo(x) = fibo(x-1) + fibo(x-2) 관계를 만족했음
        - 즉, x-1 번째 수와 x-2 번째 수를 더하면 x 번째 값이 나오는 관계를 만족하므로 재귀적인 구조를 가짐
    3. 종료 조건 찾기
       
        **[Base Case]**
        
        - fibo(x) 호출할 때, 자기보다 낮은 값을 접근하기 때문에 계속 줄어드는 것을 알 수 있음
        - 즉 마지막에 0과 1을 거치는 것을 알 수 있음
        - x 가 어떤 수가 들어와도 자기보다 하나 작은 수, 두 개 작은 수로 접근하게 되는데 0과 1을 항상 거칠 수 밖에 없음
        - 그래서 0고 1을 종료조건을 설정하면 fibo(0), fibo(1) 에서 끝날 수 있는 것

```python
def fibo(x):
    # base case
    if x == 0:
        return 0
    if x == 1:
        return 1
    
    # recursive case
    return fibo(x-1) + fibo(x-2)
```

- **왜 종료 조건을 0과 1로 나눠 놨지?**
    - x < 2 일 때, return n 을 하면 안되는 건가?

## 풀이 3) 재귀함수 + 메모이제이션 : O(n)

- O(n), n 이 최대 20 이기 때문에 통과
- 접근 방식(핵심, 중복된 계산을 하지 않는 방법)
    - 재귀함수 이용하면서 중복 계산하지 않는 방법
      
        ⇒ 중복된 계산을 저장하는 배열을 만드는 것
        
        예) fibo(18) 을 구했었다면 바로 fibo(18) 을 반환해주는 것
        
    - 메모이제이션 기법
      
        ⇒ 이미 계산한 값을 저장해 둠으로써 불필요한 중복 계산 막는 방법
        

```python
def fibo(x):
    global arr
    
    # base case
    if arr[x] != -1:
        return arr[x]
    
    # recursive case
    arr[x] = fibo(x-1) + fibo(x-2)
    return arr[x]
    
n = int(input())

arr = [-1] * (n+2)
arr[0] = 0
arr[1] = 1

print(fibo(n))
```

- 달라진 점은 arr[x] 에 값이 있는지 확인하는 코드와 arr[x] 에 값을 갱신해주는 코드
- 초기값(arr[0], arr[1])을 설정해주었기 때문에, 굳이 종료 조건으로 0, 1을 체크해줄 필요가 없음
- 재귀함수와 메모이제이션을 같이 사용했을 때의 시간 복잡도는 메모이제이션의 공간을 보면 쉽게 알 수 있음
    - arr 을 구할 때 0 ~ n 까지 구함.
    - 그리고 접근을 할 때, f(x-1) 과 f(x-2) 즉 2개를 접근하기 때문에
    - 2*n번 이라고 할 수 있는 것 → 시간 복잡도 O(n)
- 즉 재귀함수와 메모이제이션을 같이 썼을 때의 시간 복잡도는 메모이제이션의 상태 공간 크기와 관련이 있고, 실행 시 몇 개를 참조하냐에 따라서 달라짐(여기서는 f(x-1), f(x-2) 두 개)

**✅ 똑같은 값을 여러 번 구한다면, 배열에 저장하여 재사용하는 것이 좋다. (메모이제이션 기법)**

---

[출처 : 인프런, 세계 대회 진출자가 알려주는 코딩테스트 A to Z](https://www.inflearn.com/course/%EC%84%B8%EA%B3%84%EB%8C%80%ED%9A%8C-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%8C%8C%EC%9D%B4%EC%8D%AC)