---
layout: single
title:  "[ALGORITHM STUDY] 시간 복잡도와 공간 복잡도"
published : true
categories: algorithm
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true
---

# 시간 복잡도와 공간 복잡도

## 시간 복잡도

- 시간 복잡도는 프로그램이 돌아가는 데 걸리는 시간을 표기

- 주로 Big-O 표기법을 이용함

- Big-O 표기법은 동작 시간에 가장 큰 영향을 주는 값을 중심으로 시간 복잡도 표기

  - 최고 차항들만 적는 것!

  ![image]({{site.url}}/images/2025-01-01-algorithm(8)/image.png)

  - 즉 Big-O 표기법은 프로그램의 정확한 동작시간이 아니라 대략적인 동작 시간을 표시하는 것

### 자주 쓰이는 시간 복잡도

![image 1]({{site.url}}/images/2025-01-01-algorithm(8)/image 1.png)

### 실제 문제에서 시간 복잡도

> [문제]
> 배열의 크기가 n 인 배열이 정렬된 상태로 주어지고, 특정 값이 배열에 존재하는지 구하기
> 이 문제의 시간 제한 1초
> n 의 범위 : 1 ≤ n ≤ 10억

✅ **컴퓨터는 1초에 1억 번 연산을 할 수 있음**

선형 탐색 → O(n), 최악의 경우 10억 번 연산, 시간 10초 걸림(시간 제한 초과)

정렬된 상태에서 사용할 수 있는 이분 탐색 알고리즘 사용

→ O(log n), 최악의 경우 10억 번 연산해도 약 30번의 연산만에 문제 해결 가능

- log 10억이 어떻게 30으로 도출되었나?
  1. $2^{10}=1024$, 즉 약 1000 이라고 가정
  2. $10억 = 10^9$, $10^3$ 이 3번 곱해진 값
  3. 그럼 $(2^{10})^3 = 2^{30}$, log 를 취하면 30 이 되는 것!

**✅ 시간 복잡도에서 log 의 밑을 생략하면 보통 밑이 2인 log 의미**

### 시간 복잡도 사용 이유

- 내가 짠 풀이가 문제의 시간 제한을 충족하는지 코드 구현 전에 판별 가능하므로

### 문제마다의 대략적인 제한 시간

백준 → 시간 제한 항상 주어짐

프로그래머스 → 시간 제한 알려주지 않아서, 시간 제한을 5초라고 생각하고 풀면 됨

즉, 시간 제한이 표기되지 않은 코딩 테스트 문제는 대략 5초 정도라고 생각하면 됨

## 공간 복잡도

- 프로그램이 얼마나 많은 메모리를 사용하는지
- 시간 복잡도에 비해서는 크게 신경쓰지 않아도 됨

# 결론

- 나의 풀이가 1억 번 이하의 연산이 나온다면 시간 초과가 나지 않을 확률이 높다

- 나의 풀이가 5000만 개 이하의 공간을 할당하는 코드라면 메모리 초과가 나지 않을 확률이 높다